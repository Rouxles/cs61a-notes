[{"id":0,"href":"/docs/week-2/content/control/","title":"Control","section":"Week 2","content":"Control\r#\r\r Side Effects\r#\r\rSide effects occur in functions when the function alters the global environment in some form. This could be in the form of altering a variable in the global scope, or using a print statement inside a function. One easy way to tell if a function contains side effects is that if a function acts like a mathematical function, it has no side effects.\nA Mathematical function f(x) takes inputs and always provides the same outputs, without doing anything else. As a result, one input will never have two or more different outputs. If a programming function has the same property where certain outputs always provide the same inputs without doing anything else, it has no side effects\nHere are a few examples:\nExample With No Side Effects\r#\r\rdef no_side_effects(x): # Squares x return x*x no_side_effects(2) # \u0026gt;\u0026gt;\u0026gt; 4 no_side_effects(2) # \u0026gt;\u0026gt;\u0026gt; 4 In this example, every input will always map to the same output as the function does not do anything other than provide an output given an input\nExample With Side Effects\r#\r\rben = 1 def with_side_effects(x): global ben # Python usually doesn\u0026#39;t like changing global variables so this statement is needed here ben += 1 # Does the same thing as ben = ben + 1 return x*ben with_side_effects(2) # \u0026gt;\u0026gt;\u0026gt; 4 with_side_effects(2) # \u0026gt;\u0026gt;\u0026gt; 6 While this example is not going to be used in a practical setting, it serves as a good example of what a side effect is. As you can see, even though we called the function with_side_effects twice with the same input, the output was different, which goes against the definition of a mathematical function. As a result, there is a side effect in that function.\n A side note:\nWhile the print function does not change the value of any variables, it does cause a side effect by outputting something to the console, which does go against how a mathematical function works. However, while side effects are usually better to avoid where possible, print could sometimes be useful for debugging.\nAn example of a side effect that can\u0026rsquo;t be avoided is writing to a file - this is necessary at times.\n A function without side effects is also known as a pure function, while a function with side effects is also known as an impure function.\nThe \u0026lsquo;None\u0026rsquo; Value\r#\r\rIn Python, any function that does not return a value will return None, which when printed will render None to the console, and when called, will not render anything in the console.\nFor example:\ndef no_return(x): x = 1 print(no_return(2)) # \u0026gt;\u0026gt;\u0026gt; None Note that the print() function has no return value, and thus will return None when called.\nNested Print Statements\r#\r\rA nested print function is somewhat weird, but worth it to learn.\nTake this for example, what do you think will get outputted to the console? Try to think for yourself before opening the answer box below.\nprint(print(1)) Answer\r# \u0026gt;\u0026gt;\u0026gt; 1 # \u0026gt;\u0026gt;\u0026gt; None This occurs because print(1) is executed first (due to the order of operations with call functions), which outputs something to console but returns None, so this statement is essentially equal to\nprint(1) print(None) \r\r\rFor a harder example, try this one:\nprint(print(\u0026#34;x\u0026#34;), print(\u0026#34;y\u0026#34;)) Answer\r# \u0026gt;\u0026gt;\u0026gt; x # \u0026gt;\u0026gt;\u0026gt; y # \u0026gt;\u0026gt;\u0026gt; None None This occurs because the call function executes the operands from left to right, so print(\u0026quot;x\u0026quot;) is called, then print(y), and because both these values return None, the outside print function will print None, None.\nIt executes the same as the sequence below:\nprint(\u0026#34;x\u0026#34;) print(\u0026#34;y\u0026#34;) print(None, None) \r\r\r Default Arguments\r#\r\rIn the function signature, one of the inputs can have a default value. This is useful in situations where there is a most likely case for a function, but where it still makes sense for users to have some control.\nFor example, the default round() function in Python takes in 1 required parameter, with 1 optional parameter (which defaults to 0).\nround(2.5342) # \u0026gt;\u0026gt;\u0026gt; 3 round(2.5342, 2) # \u0026gt;\u0026gt;\u0026gt; 2.53 You can build your own function with default arguments by simply specifying it in the header.\nFor example:\ndef ben(baron, box=\u0026#34;tao\u0026#34;): return baron + box ben(\u0026#34;baron\u0026#34;) # \u0026gt;\u0026gt;\u0026gt; \u0026#39;barontao\u0026#39; ben(\u0026#34;baron\u0026#34;, \u0026#34;hej\u0026#34;) # \u0026gt;\u0026gt;\u0026gt; \u0026#39;baronhej\u0026#39; Without the second optional parameter hej, the function defaulted to the value tao.\nIf you have multiple default arguments, you can also override them in this way:\ndef ben(baron, box=\u0026#34;tao\u0026#34;, foo=\u0026#34;baz\u0026#34;): return baron + box + foo ben(\u0026#34;baron\u0026#34;, foo=\u0026#34;yu\u0026#34;) # \u0026gt;\u0026gt;\u0026gt; barontaoyu ben(\u0026#34;baron\u0026#34;, box=\u0026#34;yu\u0026#34;) # \u0026gt;\u0026gt;\u0026gt; baronyubaz  Multiple Return Values\r#\r\rOne aspect of Python uncommon in other languages is the allowed use of multiple return values in functions. This can be done in a function by using multiple return values separated by a comma.\nAny code that calls the function can either store it in a variable as a tuple (more on this later) or can be unpacked. For example:\ndef return_two_values(): return 1, 2 return_two_values() # \u0026gt;\u0026gt;\u0026gt; (1, 2) in tuple form a, b = return_two_values() a # \u0026gt;\u0026gt;\u0026gt; 1 b # \u0026gt;\u0026gt;\u0026gt; 2 Multiple Variable Assignment\r#\r\rThe values on the right side are evaluated first before being assigned, so you can swap the values of two variables in one line by simply doing the following:\nx, y = y, x  Boolean\r#\r\rA Boolean is a value that is either True or False, and is used frequently in many applications. For example, your mobile device would likely have a Boolean variable that stores whether your WiFi, flashlight, bluetooth etc. is turned on.\nAn expression can evaluate to a Boolean. For example:\npassed_class = grade \u0026gt;= 70 # Will evaluate either true or false depending on the condition take_shower = (not eecs_major) or did_sports Comparison Operators\r#\r\r   Operator Meaning     == Equality   != Inequality   \u0026gt; Greater Than   \u0026lt; Less Than   \u0026gt;= Greater Than or Equals   \u0026lt;= Less Than or Equals    Checking for Equality It is a common mistake to use = instead of == to check for equality. Please remember that = is for assigning a variable and cannot be used for checking for equality in a conditional statement. Python will throw a syntax error, but other languages may not, so not mixing these up is a good habit to get used to.\r\rLogical Operators\r#\r\r   Operator Meaning     and Evaluates to True if both values are True   or Evaluates to True if any of the values are True   not Evaluates to True if the value is False, else evaluates to True    Execution rules of logical operators\r#\r\rThe statements are evaluated from left to right, but sometimes, these statements do not all need to be evaluated.\nand statement procedure:\n Evaluate the left statement. If it evaluates to a False value x, the expression evaluates to x. Else, the expression evaluates to the value of the expression on the right.  or statement procedure:\n Evaluate the left statement. If it evaluates to a True value x the expression evaluates to x. Else, the expression evaluates to the value of the expression on the right.  This procedure functions using just Booleans, but strange things occur when you use other values instead.\nFor example:\n5 and 2 # \u0026gt;\u0026gt;\u0026gt; 2 5 or 2 # \u0026gt;\u0026gt;\u0026gt; 5 not 5 # \u0026gt;\u0026gt;\u0026gt; False not 0 # \u0026gt;\u0026gt;\u0026gt; True 0 and False # \u0026gt;\u0026gt;\u0026gt; 0 For the and and or operators, numbers were returned rather than Booleans due to the procedure of evaluating these logical statements.\nThere is an order of operations for Booleans (not → and → or), but generally, use brackets to make your statements clearer.\nYou can use these expressions in functions as the return value. For example:\ndef boolean_example(): return is_ben or is_tao # This will return either True or False depending on the Boolean expression.  Statements\r#\r\rA statement is executed to perform an action\nCompound Statements\r#\r\rA compound statement is a statement that contains groups of other statements.\nOne example of which are conditional statements, which give your code a way to execute a different suite of statements based on whether conditions are met\nif \u0026lt;condition\u0026gt;: this_may_be_executed(1) elif \u0026lt;condition_2\u0026gt;: this_may_be_executed(2) else: this_may_be_executed(3) An if statement looks like the code above. The block indented after the if, elif, and else statements only get executed if the code directs it to.\nFor instance, if \u0026lt;condition\u0026gt; were True, then this_may_be_executed(1) is the only statement that gets evaluated, and the ones in the other blocks are skipped over.\nIf \u0026lt;condition_2\u0026gt; were True, then this_may_be_executed(2) is the only statement that gets evaluated.\nIf both \u0026lt;condition\u0026gt; and \u0026lt;condition_2\u0026gt; are False, then this_may_be_executed(3) is evaluated.\nThis means that the code does not get executed unless certain conditions are met, which is different from call expressions where every operand gets evaluated. (This property is important for some questions)\nAdditionally, this also allows for multiple return statements in functions because only that specific block gets executed, rather than every block.\ndef returning_conditional(x): if x \u0026gt; 0: return \u0026#34;positive\u0026#34; if x \u0026lt; 0: return \u0026#34;negative\u0026#34; if x == 0: return \u0026#34;neutral\u0026#34;  While Loop\r#\r\rA while loop in Python executes a block of code as long as a condition is true. This loop keeps on getting checked after each iteration.\nOne problem of a while loop is that an infinite loop can easily occur if you aren\u0026rsquo;t careful.\ncounter = 1 while counter \u0026lt; 5: print(counter) counter += 1 \u0026#39;\u0026#39;\u0026#39; \u0026gt; 1 \u0026gt; 2 \u0026gt; 3 \u0026gt; 4 \u0026#39;\u0026#39;\u0026#39; In the example above, 5 does not get printed because during that iteration, the counter variable is already 5, and the conditional 5 \u0026lt; 5 returns False.\nA while loop is very useful if you do not know how many repeats of the code you need to do, while a for loop (explained on another page) is better if you know how many loops to do.\nBreak Statement\r#\r\rIf you ever want to prematurely leave a code block, you can use the break keyword.\nwhile True: print(1) break # \u0026gt;\u0026gt;\u0026gt; 1 The above code would usually give an infinite loop, but the break statement prevents that from happening.\n For Loop\r#\r\rA for loop in Python executes a block of code for a set number of times. This is more complicated to understand than the while loop, but is more useful in some situations.\nThe range() function\r#\r\rThe range() function is used quite often in conjunction with the for loop. There are 3 arguments that range() takes, each of which will be demonstrated below:\nfor n in range(5): # equivalent to range(0, 5) print(n) \u0026#39;\u0026#39;\u0026#39; \u0026gt; 0 \u0026gt; 1 \u0026gt; 2 \u0026gt; 3 \u0026gt; 4 \u0026#39;\u0026#39;\u0026#39; for n in range(1, 5): print(n) \u0026#39;\u0026#39;\u0026#39; \u0026gt; 1 \u0026gt; 2 \u0026gt; 3 \u0026gt; 4 \u0026#39;\u0026#39;\u0026#39; for n in range(5, 0, -1): print(n) \u0026#39;\u0026#39;\u0026#39; \u0026gt; 5 \u0026gt; 4 \u0026gt; 3 \u0026gt; 2 \u0026gt; 1 \u0026#39;\u0026#39;\u0026#39; As can be seen in the 3 examples above, the range() function works well with the for loop.\nWhen range() is passed only 1 parameter in a for loop, it starts off at 0, then ends off at the integer before n. With 2 parameters, the for loop\u0026rsquo;s value starts off at the first parameter\u0026rsquo;s value, then ends off at the integer before the second parameter\u0026rsquo;s value. The last parameter specifies the amount n should be changed by each loop, whether it be negative or a value other than 1.\n"},{"id":1,"href":"/docs/week-2/content/higher-order-functions/","title":"Higher Order Functions","section":"Week 2","content":"Higher Order Functions\r#\r\rDesigning Functions\r#\r\rDescribing Functions\r#\r\r   Aspect Example     The domain of a function is the expected range of inputs (similarly to a domain in mathematics) x is a string.   The range of a function is the set of output values that could be returned Function square returns a non-negative number.   The behavior of a (pure) function is the relationship between the input and the output Function square returns the square of an input x.    Don\u0026rsquo;t Repeat Yourself!\r#\r\rWhen making a function, give each function exactly one job, but allow it to be flexible to apply to many related situations. Doing this allows you to remove redundant code and make your code clearer to read, and easier to write.\nGeneralization\r#\r\rIf you see a common structure, you can refactor your code to move the redundant code to a function and call that instead.\nFor example, if we take this code block below:\ndef print_ben_if_positive(n): if n \u0026gt; 0: print(\u0026#34;ben\u0026#34;) def print_ben_if_positive(n): if n \u0026gt; 0: print(\u0026#34;tao\u0026#34;) We can see that the if statement is duplicated, so we can take that logic to another function instead, removing redundant code.\ndef positive_print(number, message): if number \u0026gt; 0: print(message) positive_print(n, \u0026#34;ben\u0026#34;) positive_print(n, \u0026#34;tao\u0026#34;) Higher-order Functions\r#\r\rA higher-order function is a function that takes another function as an argument, or returns a function as its result.\nFunctions as Arguments\r#\r\rA function can take another function as an argument.\nfrom operator import add, sub def function_in_function(adding_function, x, y): return adding_function(x, y) function_in_function(add, 3, 2) # \u0026gt;\u0026gt;\u0026gt; 5 function_in_function(sub, 3, 2) # \u0026gt;\u0026gt;\u0026gt; 1 In the example above, we passed the add and sub functions to the function function_in_function. This is an example of a higher order function.\nNote that in the call functions themselves, add and sub were called rather than add() and sub(). This is because of how call functions are evaluated. Running add() directly will make the Python interpreter try to evaluate the function itself with no parameters, which would not work, while simply typing add will allow function_in_function to evaluate add() with the proper parameters.\r\rFunctions as Return Values\r#\r\rAnother way to have a higher order function is to return a function.\nFunctions created in other functions are bound to names in their local frame, allowing for cleaner naming when creating function calls. For example:\ndef make_adder(magnitude): def adder(n): return n + magnitude return adder add_two = make_adder(2) add_three = make_adder(3) print(add_two(2), add_three(2)) # \u0026gt;\u0026gt;\u0026gt; 4 5 While the example above may not have much practical use, it shows the process of returning a function within a function, making this another higher order function. Take your time to digest how the above two examples work. This will be harder to conceptualize at the beginning.\nCall Expressions as operator expressions\r#\r\rYou can run a function like make_adder(2)(3) which will return 5. Why is that? Let\u0026rsquo;s look at how the call function order works.\n make_adder(2) is first evaluated, which returns a function adder similarly to the function above. Due to adder being returned from the operator, the final statement will end up being adder(3), leading to 5 being the final output  Lambda Expressions\r#\r\rLambda expressions pretty much work the same way as regular functions, other than the fact that these functions are anonymous - they do not have a name assigned to it.\nThe syntax looks like the following:\nlambda \u0026lt;parameters\u0026gt;: \u0026lt;expression\u0026gt; For instance:\ndouble = lambda x: y*2 double(3) # \u0026gt;\u0026gt;\u0026gt; 6 While this may not seem very useful in this context, there are quite a few uses for it. The main idea is that lambda functions are better suited for functions that you want to access in the short term, or only access once.\nA lambda function does not contain any statements at all, including if statements and return statements.\nFor instance, instead of doing\nfrom operator import add def square(x): return x**2 add(2, square(2)) You can do the following:\nfrom operator import add add(2, lambda x: x**2) Conditional Expressions\r#\r\rlambda functions not allowing statements can be quite limiting, but that is where conditional expressions come in.\nA conditional expression has a form that almost reads like English:\n\u0026lt;do this (true)\u0026gt; if \u0026lt;condition\u0026gt; else \u0026lt;do this (false)\u0026gt; This may be strange if you\u0026rsquo;re used to ternary operators in other languages (for example JavaScript) as the order of reading the Python statement may be a bit strange.\nHowever, the operation order is the following:\n Check the truthiness of \u0026lt;condition\u0026gt; If true, evaluate \u0026lt;do this (true)\u0026gt; Else, evaluate \u0026lt;do this (false)\u0026gt;  In conjunction with lambda functions, you can do the following:\nlambda x: x if x \u0026gt; 0 else 0 The code block above returns the input if it is positive, else returns 0.\n"},{"id":2,"href":"/docs/week-1/content/introduction/","title":"Introduction to the Basics of Python","section":"Week 1","content":"The first week of CS61A is pretty simple - get used to your coding environment and a few of the basics of Python.\nLab 0\r#\r\rWhile this is optional, it\u0026rsquo;s probably best to do it just to get used to the very basics of Python as well as ok.py, the autograder used in CS61A.\nYou can (and should!) visualize how Python programs works with PyTutor or execute programs with code.cs61a.org, but it\u0026rsquo;s probably better to use something like VSCode instead.\nAlternatively, if you have a bit of experience with other coding languages, you could look at learn X in Y\u0026rsquo;s page which will quickly get you up to speed with the syntax of Python.\n Basics of Python\r#\r\rExpressions + Values\r#\r\r Programs work to manipulate values Expressions in programs evaluate to values Values can have different data types (string, float, boolean, integer, etc.)  Python evaluates these expressions, and then (potentially) displays its values\nData Types\r#\r\r   Data Type Example Values     Integers 2, 44, 25   Floats 3.14, 2.73, 69.69   Booleans True, False   Strings Hi, ben    Operators\r#\r\rThese are pretty self-explanatory\n   Operator Example Expression What it does     + 10 + 2 Adds two values together   - 10 - 2 Subtracts values   * 10*2 Multiplies values   / 10/2 Divides values   // 9//2 Takes the floor of the divided value (result on the left would evaluate to 4)   % 9%2 Takes the remainder of the expression (result on the left would evaluate to 1)   ** 2**2 Finds the value of the left value to the power of the right value    Call Expressions\r#\r\rOftentimes, however, expressions use function calls rather than operators (and the operators above have call function equivalents!)\nFor example, running add(10, 2) does the same thing as 10 + 2 as shown in the example above, but with different form.\nSo the question is: Why use call functions?\nOne possible reason is that call functions are sometimes a lot easier to understand, especially when you have multiple nested call functions (as opposed to multiple mathematical operators)\nA call function always executes the same way with the same procedure, which goes as follows:\nadd(10, 69) add is the operator, 10 and 69 are the operands in this instance.\nPython will first evaluate the operator (and), then will evaluate the operands (10, then 69), then apply the operator (function) to the operands (arguments), in that order, which can be summarized as follows:\n Evaluate the operator  Usually this means check to see if it exists, but the operator itself may be a function in some situations.   Evaluate the operand(s) Apply the operator to the operand(s)  Operators and more commonly, operands can also be written as expressions, so these must be evaluated before step 3 can occur (meaning that if you have any sort of errors in that code block, Python will throw an error!)\nExample of nested expressions\r#\r\rfrom operator import add add(add(3,add(3,2)),add(add(5,4),add(7,6))) While the above example above is very impractical and will not appear in any sort of serious coding, it is a pretty good example of how Python evaluates nested expressions.\nLet\u0026rsquo;s unpack how Python deals with the above expression!\n Python reads from left to right in this expression, so first the add operator will be evaluated Next, the leftmost argument for add will be read, which in this case is the large block add(3,add(3,2)) As this is still another call function, the add will be evaluated, with the operands 3 and add(3,2) 3 is a \u0026lsquo;base case\u0026rsquo;, so that does not need to be further evaluated, but add(3,2) goes through the same procedure, which will then evaluate to 5. Now because the inner add function has been fully evaluated, the value is calculated in reverse order  3 + 5 is calculated, which will return 8 for the first argument.   Same thing happens for the other operand, which will then evaluate to 22 22 and 8 get summed, which will then result in 30  A visual representation (in the form of an expression tree) of what was said above can be seen below.\n Names\r#\r\rA name can be bound to a value. This does not necessarily need to be a variable - it could also be a function or an expression for instance.\nNames are often used because they can be reused in different parts of the code. A name that\u0026rsquo;s bound to a value is known as a variable.\nFor example:\nx = 2 y = 3 print(x + y) # Returns 5 print(x - y) # Returns -1 These values can also change:\nx = 2 print(x) # \u0026gt;\u0026gt;\u0026gt; 2 x = x + 5 print(x) # \u0026gt;\u0026gt;\u0026gt; 7 The equals sign used above is not similar to the one used in mathematics; it is used for assignment rather than equality, which means that you set a value to the variable.\nThis assignment statement works by\n Evaluating the expression on the right of the = Binding the value of the expression to the name on the left side of the =  Environment Diagrams\r#\r\rThese are very useful to visualize how the Python interpreter thinks (and also appear somewhat often in exam questions). PyTutor is a very good resource to generate these environment diagrams if you ever get confused about how assignment works.\nFunctions\r#\r\rFunctions are very useful in programming languages in general because they allow lines of code to be easily reused. Functions, however, are slightly more complicated than variables due to the local and global frames (more on that later).\nWhat is a function?\r#\r\rA function is a sequence of code that can be called on at any point in the program.\nWhile there are built in functions (like the add(a, b) function used earlier), sometimes, they need to be built by hand.\nA function has two portions: an input (the arguments a and b) and an output (a return value). These are not required, but depending on the use case of the function, they are very useful.\nHow do we write a function?\r#\r\rThere are two common methods to write a function in Python, with the most common one being the def statement, which can be written in the format below:\ndef \u0026lt;name\u0026gt;(\u0026lt;parameters\u0026gt;): return \u0026lt;expression\u0026gt; For example, instead of using the built-in add() function from Python, we can create our own by doing the following:\ndef add(a, b): return a + b After the code is defined (e.g. below the function definition), you can then call it:\nadd(5, 6) # \u0026gt;\u0026gt;\u0026gt; 11 In CS61A, the first line is the function signature, and all lines thereafter (there can be more than 1) are considered the function body.\nThe return keyword\r#\r\rIn a Python function statement, the return keyword is vital. What it does is return a value to the place where the function was called, and then exits the function (both properties are very important to remember!)\nThe return keyword acts very differently to print, even if they are in the same function. print does not do any assignment, while return does. The example below may help illustrate my point:\ndef example(x): print(x) return x*2 value = example(3) # Running the above line will print 3 first, then assign 3*2 to value print(value) # \u0026gt;\u0026gt;\u0026gt; 6 Frames\r#\r\rThere are different frames, which you can think of as different rooms in the same house.\nThe global frame is an environment that contains all the variables and functions that were created in the main body of the program.\nA function\u0026rsquo;s local frame is a child of the global frame, where it has its own set of variables that can\u0026rsquo;t be accessed outside the function. For example:\nunhelpful_name = 0 # variable in the global frame def unhelpful_function(unhelpful_name): # variable in the local frame (even though it has the same name it isn\u0026#39;t the same variable) return unhelpful_name # \u0026gt;\u0026gt;\u0026gt; 2 # The above will return 2 as opposed to 0 because the unhelpful_name variable called in the function is the one passed into the function. unhelpful_function(2) Name Lookup Rules\r#\r\rPython looks up names in a user-defined function using the following logic:\n Look it up in the local frame If the name is not in the local frame, look for the name in the parent frame If the name is not in any searched frame, throw a NameError.   Ending Notes\r#\r\rIf you don\u0026rsquo;t understand any of this, it is very important to ask for more help, whether that be from your peers or from your TAs, or even searching on the internet. Another very useful resource (especially for understanding how frames work) is PyTutor. Please use it.\n"}]