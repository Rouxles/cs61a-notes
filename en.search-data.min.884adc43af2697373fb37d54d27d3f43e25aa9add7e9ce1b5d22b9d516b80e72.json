[{"id":0,"href":"/docs/week-5/content/containers/","title":"Containers","section":"Week 5","content":"Containers\r#\r\rLists\r#\r\rA list is a container that can hold a sequence of information (usually related information).\nLists can hold any Python values (not the same behaviour in every language), including other lists/objects etc.\nempty = [] # empty list B = [\u0026#34;Ben\u0026#34;, \u0026#34;Box\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;Bufy\u0026#34;] # Strings numbers = [2, 5, 7] # Integers floats = [2.0, 3.5, 7.5] # Floats nested = [[2, 3], 3, 4] # Storing a list inside a list mixed = [\u0026#34;Hi\u0026#34;, 2, 3.2] # Different data types inside a list List Length\r#\r\rThe globally defined len() function in Python allows you to find the length of an array, and can be called by simply passing in the array as an argument.\nlst = [2, 3, 4, 5] \u0026gt;\u0026gt;\u0026gt; len(lst) 4 This could be useful if you wanted to count the number of elements in an array to calculate the average for instance.\nWhile you could store the length of the list in a variable, it\u0026rsquo;s usually not a good idea because once the list is updated, the variable storing the length will not be updated. As a result, it\u0026rsquo;s not a bad idea to always call len() when you need to find the length unless you have a specific use for storing an outdated list length.\nlength_of_list = len(lst) # 4 lst = lst + [6] # [2, 3, 4, 5, 6], more on list concatenation later \u0026gt;\u0026gt;\u0026gt; len(lst) 5 \u0026gt;\u0026gt;\u0026gt; length_of_list 4 Indexing (Accessing List Elements)\r#\r\rNow that we have a list, well, cool! But how do we access individual elements?\nWe can use indexing for that. Each element in the list has its own index (indexes start on 0), and can be accessed by putting the index of the element in question in a square bracket.\nlst = [2, 3, 4, 5] # Index: # 0 1 2 3 \u0026gt;\u0026gt;\u0026gt; lst[0] 2 \u0026gt;\u0026gt;\u0026gt; lst[3] 5 to_get = 2 \u0026gt;\u0026gt;\u0026gt; lst[to_get] 4 \u0026gt;\u0026gt;\u0026gt; lst[4] # Will throw an error In Python, negative indices are also possible. Calling a negative index on a list will return the elements starting from the back.\n\u0026gt;\u0026gt;\u0026gt; lst[-1] 5 \u0026gt;\u0026gt;\u0026gt; lst[-2] 4 \u0026gt;\u0026gt;\u0026gt; lst[-5] # Will throw an error Notice how the first element from the back is -1 rather than 0? A somewhat easy way to imagine why that\u0026rsquo;s the case is to imagine negative indices being shorthand for len(lst) - \u0026lt;index\u0026gt; — so for example, lst[-1] would be len(lst) — equal to 4 — then minus 1, which would give 3, so it\u0026rsquo;s effectively the same thing as calling lst[3].\nList Concatenation\r#\r\rYou can add two lists together by using the + operator, or the add function, meaning that you can change the information stored in a list.\nFor now, you will only be able to add to a list with this operator (the - operator does not work on lists), but in the next page, you will see a method of how to take a subset of a list, which essentially does the same thing as removing elements in a slightly safer manner.\nlist1 = [1, 2, 3, 4] list2 = [5] \u0026gt;\u0026gt;\u0026gt; list1 + list2 [1, 2, 3, 4, 5] \u0026gt;\u0026gt;\u0026gt; add(list1, [6]) [1, 2, 3, 4, 6] .append/.push\nFor those used to other languages, you may see .append and .push used, but those actually change the values of the array, which can easily be circumvented by just adding two lists together and assigning that to a new variable. That way you have access to old versions of your variables, making your code slightly easier to read/debug.\n\rList Repetition\r#\r\rYou can also use the * operator and the mul function with lists — however you can only multiply (vanilla Python) lists with an integer, which would repeat the elements already in the list. For example:\nlst = [1, 2, 3] lst3 = lst * 3 \u0026gt;\u0026gt;\u0026gt; lst3 [1, 2, 3, 1, 2, 3, 1, 2, 3] Nested Lists\r#\r\rAs briefly mentioned earlier, you can also put lists inside of lists in Python. For example:\nlst = [[1, 2], [3, 4, \u0026#34;Hi\u0026#34;], []] If you think about this in the larger picture, lst itself only has 3 elements — 3 separate lists (with the contents inside them being irrelevant until they need to be accessed). However, once you access one of the lists, you then get another list returned (similarly to how higher-order functions worked when they returned other functions), which can then be indexed again to get a specific value.\n\u0026gt;\u0026gt;\u0026gt; lst[0] [1, 2] \u0026gt;\u0026gt;\u0026gt; lst[0][1] 2 So, knowing that information, what is the length of lst and the length of lst[2]?\nAnswer\r\u0026gt;\u0026gt;\u0026gt; len(lst) # Is somewhat equivalent to doing len([[], [], []]), or maybe len([\u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;]) - just different ways to view it here 3 \u0026gt;\u0026gt;\u0026gt; len(lst[1]) # Refers to the length of [] 0 \r\r\rContainment\r#\r\rYou can use the in operator to see whether a value is in a container. This operator, like ==, \u0026lt;, \u0026gt;, etc. returns a Boolean value in this context.\nlst = [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; 1 in lst True \u0026gt;\u0026gt;\u0026gt; 2 in lst True \u0026gt;\u0026gt;\u0026gt; \u0026#34;2\u0026#34; in lst False \u0026gt;\u0026gt;\u0026gt; not (3 in lst) False \u0026gt;\u0026gt;\u0026gt; 12 in lst False \u0026gt;\u0026gt;\u0026gt; [1] in lst False # This one is false because none of the elements in lst are lists themselves in (boolean operator) (checks if something is inside container (or string))\nFor Statements\r#\r\rYou can check the Control page to see the fundamental information on for loops and the range() function.\nFor lists, the range() function does not always need to be used.\nFor-in Loops\r#\r\rIf you loop through a list, you can iterate through it without using range():\nlst = [1, 2, 3] for elem in lst: # In every iteration, it binds a value from `lst` to `elem` print(elem) # Console output: # 1 # 2 # 3 If you need to access deeper than 1 level, you can use a nested for-in loop.\nSequence Unpacking Example\r#\r\rlst = [[1, 2], [3, 4]] for a, b in lst: print(a + b) # Console output: # 3 # 7 Each name is bound to a value in this case (just like in multiple assignment)\nList Comprehensions\r#\r\rList comprehension in Python is a very elegant way to create a new list by mapping an existing list\u0026rsquo;s values to a new list.\nFor example, if you wanted to add 1 to every integer in a list, you could use list comprehension in the following manner:\nlst = [1, 2, 3, 4, 5] lst_plus_1 = [x + 1 for x in lst] # [2, 3, 4, 5, 6] And if you wanted to have a list that only contained odd numbers + 1, you could do the following:\nodd_lst_plus_1 = [x + 1 for x in lst if x % 2 == 0] # [2, 4, 6] The if statement acts as a filter — it only puts elements in the new array if it passes a condition.\nWe can generalize this structure to the following:\n[\u0026lt;map expression\u0026gt; for \u0026lt;name\u0026gt; in \u0026lt;iterator\u0026gt; if \u0026lt;condition\u0026gt;] The execution procedure for this (in an environment diagram) would be to:\n Add a new frame with its current frame as its parent Create an empty result list For each element in iterator, bind it to name  If condition returns a true value, then add the value of map expression to the result list in step 2.    Strings vs Lists\r#\r\rStrings and lists have very similar behaviour (although naturally they do have some differences). They both can act as an iterator (so they can be used as an iterator in a for loop.\nSimilarities:\nstring = \u0026#34;ben\u0026#34; len(string) # 3 string[2] # n string + \u0026#34; baron\u0026#34; # ben baron However, they differ in these aspects:\nlst = [1] string = \u0026#34;B\u0026#34; string[0] == string # True lst[0] == lst # False (This is because lst[0] is equivalent to 1 as opposed to [1]) Additionally, the in operator will match substrings inside a string, but will not do so for a list.\nlst = [\u0026#34;bent\u0026#34;, \u0026#34;tao\u0026#34;] string = \u0026#34;bent\u0026#34; \u0026#34;ben\u0026#34; in lst # False \u0026#34;ben\u0026#34; in string # True "},{"id":1,"href":"/docs/week-2/content/control/","title":"Control","section":"Week 2","content":"Control\r#\r\r Side Effects\r#\r\rSide effects occur in functions when the function alters the global environment in some form. This could be in the form of altering a variable in the global scope, or using a print statement inside a function. One easy way to tell if a function contains side effects is that if a function acts like a mathematical function, it has no side effects.\nA Mathematical function f(x) takes inputs and always provides the same outputs, without doing anything else. As a result, one input will never have two or more different outputs. If a programming function has the same property where certain outputs always provide the same inputs without doing anything else, it has no side effects\nHere are a few examples:\nExample With No Side Effects\r#\r\rdef no_side_effects(x): # Squares x return x*x no_side_effects(2) # \u0026gt;\u0026gt;\u0026gt; 4 no_side_effects(2) # \u0026gt;\u0026gt;\u0026gt; 4 In this example, every input will always map to the same output as the function does not do anything other than provide an output given an input\nExample With Side Effects\r#\r\rben = 1 def with_side_effects(x): global ben # Python usually doesn\u0026#39;t like changing global variables so this statement is needed here ben += 1 # Does the same thing as ben = ben + 1 return x*ben with_side_effects(2) # \u0026gt;\u0026gt;\u0026gt; 4 with_side_effects(2) # \u0026gt;\u0026gt;\u0026gt; 6 While this example is not going to be used in a practical setting, it serves as a good example of what a side effect is. As you can see, even though we called the function with_side_effects twice with the same input, the output was different, which goes against the definition of a mathematical function. As a result, there is a side effect in that function.\n A side note:\nWhile the print function does not change the value of any variables, it does cause a side effect by outputting something to the console, which does go against how a mathematical function works. However, while side effects are usually better to avoid where possible, print could sometimes be useful for debugging.\nAn example of a side effect that can\u0026rsquo;t be avoided is writing to a file - this is necessary at times.\n A function without side effects is also known as a pure function, while a function with side effects is also known as an impure function.\nThe \u0026lsquo;None\u0026rsquo; Value\r#\r\rIn Python, any function that does not return a value will return None, which when printed will render None to the console, and when called, will not render anything in the console.\nFor example:\ndef no_return(x): x = 1 print(no_return(2)) # \u0026gt;\u0026gt;\u0026gt; None Note that the print() function has no return value, and thus will return None when called.\nNested Print Statements\r#\r\rA nested print function is somewhat weird, but worth it to learn.\nTake this for example, what do you think will get outputted to the console? Try to think for yourself before opening the answer box below.\nprint(print(1)) Answer\r# \u0026gt;\u0026gt;\u0026gt; 1 # \u0026gt;\u0026gt;\u0026gt; None This occurs because print(1) is executed first (due to the order of operations with call functions), which outputs something to console but returns None, so this statement is essentially equal to\nprint(1) print(None) \r\r\rFor a harder example, try this one:\nprint(print(\u0026#34;x\u0026#34;), print(\u0026#34;y\u0026#34;)) Answer\r# \u0026gt;\u0026gt;\u0026gt; x # \u0026gt;\u0026gt;\u0026gt; y # \u0026gt;\u0026gt;\u0026gt; None None This occurs because the call function executes the operands from left to right, so print(\u0026quot;x\u0026quot;) is called, then print(y), and because both these values return None, the outside print function will print None, None.\nIt executes the same as the sequence below:\nprint(\u0026#34;x\u0026#34;) print(\u0026#34;y\u0026#34;) print(None, None) \r\r\r Default Arguments\r#\r\rIn the function signature, one of the inputs can have a default value. This is useful in situations where there is a most likely case for a function, but where it still makes sense for users to have some control.\nFor example, the default round() function in Python takes in 1 required parameter, with 1 optional parameter (which defaults to 0).\nround(2.5342) # \u0026gt;\u0026gt;\u0026gt; 3 round(2.5342, 2) # \u0026gt;\u0026gt;\u0026gt; 2.53 You can build your own function with default arguments by simply specifying it in the header.\nFor example:\ndef ben(baron, box=\u0026#34;tao\u0026#34;): return baron + box ben(\u0026#34;baron\u0026#34;) # \u0026gt;\u0026gt;\u0026gt; \u0026#39;barontao\u0026#39; ben(\u0026#34;baron\u0026#34;, \u0026#34;hej\u0026#34;) # \u0026gt;\u0026gt;\u0026gt; \u0026#39;baronhej\u0026#39; Without the second optional parameter hej, the function defaulted to the value tao.\nIf you have multiple default arguments, you can also override them in this way:\ndef ben(baron, box=\u0026#34;tao\u0026#34;, foo=\u0026#34;baz\u0026#34;): return baron + box + foo ben(\u0026#34;baron\u0026#34;, foo=\u0026#34;yu\u0026#34;) # \u0026gt;\u0026gt;\u0026gt; barontaoyu ben(\u0026#34;baron\u0026#34;, box=\u0026#34;yu\u0026#34;) # \u0026gt;\u0026gt;\u0026gt; baronyubaz  Multiple Return Values\r#\r\rOne aspect of Python uncommon in other languages is the allowed use of multiple return values in functions. This can be done in a function by using multiple return values separated by a comma.\nAny code that calls the function can either store it in a variable as a tuple (more on this later) or can be unpacked. For example:\ndef return_two_values(): return 1, 2 return_two_values() # \u0026gt;\u0026gt;\u0026gt; (1, 2) in tuple form a, b = return_two_values() a # \u0026gt;\u0026gt;\u0026gt; 1 b # \u0026gt;\u0026gt;\u0026gt; 2 Multiple Variable Assignment\r#\r\rThe values on the right side are evaluated first before being assigned, so you can swap the values of two variables in one line by simply doing the following:\nx, y = y, x  Boolean\r#\r\rA Boolean is a value that is either True or False, and is used frequently in many applications. For example, your mobile device would likely have a Boolean variable that stores whether your WiFi, flashlight, bluetooth etc. is turned on.\nAn expression can evaluate to a Boolean. For example:\npassed_class = grade \u0026gt;= 70 # Will evaluate either true or false depending on the condition take_shower = (not eecs_major) or did_sports Comparison Operators\r#\r\r   Operator Meaning     == Equality   != Inequality   \u0026gt; Greater Than   \u0026lt; Less Than   \u0026gt;= Greater Than or Equals   \u0026lt;= Less Than or Equals    Checking for Equality It is a common mistake to use = instead of == to check for equality. Please remember that = is for assigning a variable and cannot be used for checking for equality in a conditional statement. Python will throw a syntax error, but other languages may not, so not mixing these up is a good habit to get used to.\r\rLogical Operators\r#\r\r   Operator Meaning     and Evaluates to True if both values are True   or Evaluates to True if any of the values are True   not Evaluates to True if the value is False, else evaluates to True    Execution rules of logical operators\r#\r\rThe statements are evaluated from left to right, but sometimes, these statements do not all need to be evaluated.\nand statement procedure:\n Evaluate the left statement. If it evaluates to a False value x, the expression evaluates to x. Else, the expression evaluates to the value of the expression on the right.  or statement procedure:\n Evaluate the left statement. If it evaluates to a True value x the expression evaluates to x. Else, the expression evaluates to the value of the expression on the right.  This procedure functions using just Booleans, but strange things occur when you use other values instead.\nFor example:\n5 and 2 # \u0026gt;\u0026gt;\u0026gt; 2 5 or 2 # \u0026gt;\u0026gt;\u0026gt; 5 not 5 # \u0026gt;\u0026gt;\u0026gt; False not 0 # \u0026gt;\u0026gt;\u0026gt; True 0 and False # \u0026gt;\u0026gt;\u0026gt; 0 For the and and or operators, numbers were returned rather than Booleans due to the procedure of evaluating these logical statements.\nThere is an order of operations for Booleans (not → and → or), but generally, use brackets to make your statements clearer.\nYou can use these expressions in functions as the return value. For example:\ndef boolean_example(): return is_ben or is_tao # This will return either True or False depending on the Boolean expression.  Statements\r#\r\rA statement is executed to perform an action\nCompound Statements\r#\r\rA compound statement is a statement that contains groups of other statements.\nOne example of which are conditional statements, which give your code a way to execute a different suite of statements based on whether conditions are met\nif \u0026lt;condition\u0026gt;: this_may_be_executed(1) elif \u0026lt;condition_2\u0026gt;: this_may_be_executed(2) else: this_may_be_executed(3) An if statement looks like the code above. The block indented after the if, elif, and else statements only get executed if the code directs it to.\nFor instance, if \u0026lt;condition\u0026gt; were True, then this_may_be_executed(1) is the only statement that gets evaluated, and the ones in the other blocks are skipped over.\nIf \u0026lt;condition_2\u0026gt; were True, then this_may_be_executed(2) is the only statement that gets evaluated.\nIf both \u0026lt;condition\u0026gt; and \u0026lt;condition_2\u0026gt; are False, then this_may_be_executed(3) is evaluated.\nThis means that the code does not get executed unless certain conditions are met, which is different from call expressions where every operand gets evaluated. (This property is important for some questions)\nAdditionally, this also allows for multiple return statements in functions because only that specific block gets executed, rather than every block.\ndef returning_conditional(x): if x \u0026gt; 0: return \u0026#34;positive\u0026#34; if x \u0026lt; 0: return \u0026#34;negative\u0026#34; if x == 0: return \u0026#34;neutral\u0026#34;  While Loop\r#\r\rA while loop in Python executes a block of code as long as a condition is true. This loop keeps on getting checked after each iteration.\nOne problem of a while loop is that an infinite loop can easily occur if you aren\u0026rsquo;t careful.\ncounter = 1 while counter \u0026lt; 5: print(counter) counter += 1 \u0026#39;\u0026#39;\u0026#39; \u0026gt; 1 \u0026gt; 2 \u0026gt; 3 \u0026gt; 4 \u0026#39;\u0026#39;\u0026#39; In the example above, 5 does not get printed because during that iteration, the counter variable is already 5, and the conditional 5 \u0026lt; 5 returns False.\nA while loop is very useful if you do not know how many repeats of the code you need to do, while a for loop (explained on another page) is better if you know how many loops to do.\nBreak Statement\r#\r\rIf you ever want to prematurely leave a code block, you can use the break keyword.\nwhile True: print(1) break # \u0026gt;\u0026gt;\u0026gt; 1 The above code would usually give an infinite loop, but the break statement prevents that from happening.\n For Loop\r#\r\rA for loop in Python executes a block of code for a set number of times. It provides a cleaner way to write while loops as long as they are iterating over some sort of sequence, for instance, the range() function.\nThe for loop syntax is as follows:\nfor \u0026lt;name\u0026gt; in \u0026lt;expression\u0026gt;: \u0026lt;suite\u0026gt;  Evaluate \u0026lt;expression\u0026gt; — this must evaluate to an iterable value (strings, lists (more on this later), range()) etc For each element in that \u0026lt;expression\u0026gt; (in order), bind \u0026lt;name\u0026gt; to the element in the current frame  Execute the suite, with \u0026lt;name\u0026gt; bound to a new value.    That might be slightly confusing for now, but just know that you can do everything a for loop can do with a while loop. So, if you see an example that uses a for loop, you can re-imagine it as a while loop, and it would still act the same.\nThe range() function\r#\r\rThe range() function is used quite often in conjunction with the for loop. It represents a sequence of integers. There are 3 arguments that range() takes, each of which will be explained, then demonstrated below:\n If there is just one argument x, range(x) will start on 0, then keep increasing the number by 1 until x - 1 (0 \u0026lt;= i \u0026lt; x where i is the current value) If there are two arguments x, y, range(x, y) will start on x, then keep increasing the number by 1 until y - 1. If there are three arguments x, y, z, range(x, y, z) will start on x, then keep incrementing the number by z (this can be negative), and then end on y - z.  for n in range(5): # equivalent to range(0, 5) print(n) \u0026#39;\u0026#39;\u0026#39; \u0026gt; 0 \u0026gt; 1 \u0026gt; 2 \u0026gt; 3 \u0026gt; 4 \u0026#39;\u0026#39;\u0026#39; for n in range(1, 5): print(n) \u0026#39;\u0026#39;\u0026#39; \u0026gt; 1 \u0026gt; 2 \u0026gt; 3 \u0026gt; 4 \u0026#39;\u0026#39;\u0026#39; for n in range(5, 0, -1): print(n) \u0026#39;\u0026#39;\u0026#39; \u0026gt; 5 \u0026gt; 4 \u0026gt; 3 \u0026gt; 2 \u0026gt; 1 \u0026#39;\u0026#39;\u0026#39; As can be seen in the 3 examples above, the range() function works well with the for loop.\nWhen range() is passed only 1 parameter in a for loop, it starts off at 0, then ends off at the integer before n. With 2 parameters, the for loop\u0026rsquo;s value starts off at the first parameter\u0026rsquo;s value, then ends off at the integer before the second parameter\u0026rsquo;s value. The last parameter specifies the amount n should be changed by each loop, whether it be negative or a value other than 1.\n"},{"id":2,"href":"/docs/week-3/content/design/","title":"Design","section":"Week 3","content":"Design\r#\r\rAbstraction\r#\r\rAbstraction (in a CS context) is broadly understood as extracting relevant information from other sources in order to simplify the codebase.\nAbstraction by Parameterization\r#\r\rThis is pretty much DRY (Don\u0026rsquo;t Repeat Yourself). Instead of hard-coding code that have similar structure, you could write a function that takes in parameters (arguments) which can be used to do the same thing. (Taken from CS61A Fall 2021 Design Slides)\ninterest = 1 + 0.6 * 2 interest2 = 1 + 0.9 * 4 interest3 = 1 + 2.1 * 3 As you can see above, there is a bunch of redundant code, which could be condensed into the function below (and then subsequently called with its respective arguments)\ndef interest(rate, years): return 1 + rate * years In this example, the removed detail, or the abstracted detail are the values themselves.\nAbstraction by Specification\r#\r\rInstead of building your own round function, you could just use Python\u0026rsquo;s built-in implementation, has its own specification for the inputs that it takes in (a number and the number of digits to round to), and then outputs a number based on that.\nAs a result, you could use this implementation of the round function in your code to save from implementing the code yourself.\nUsing an Abstraction\r#\r\rSay we have a specification for square(n) that takes an input n and returns the square of n. If we had this implemented already, we could use this function in our code. As a result, the code block below would run without any problems due to this abstraction.\ndef sum_squares(x, y): return square(x) + square(y) Implementing the Abstraction\r#\r\rThere are many valid ways to implement this function, but some pieces of code are less efficient or have certain effects that you may not intend for it to have.\nFor example, take a look at the possible implementations of square:\ndef square(n): return n**2 square = lambda n: n*n square = lambda n: (n*(n-1)) + n Notice how the bottom implementation takes more computational resources than the 2 implementations above? This will be more important as the pieces of code written get more complicated — the size of the program and the time efficiency can be effected by poor implementations.\nReasonable Names\r#\r\rChoosing Names\r#\r\rWhile the computer does not care about names, it greatly improves readability for humans — even yourself when you look back at the code at a later date.\nNames should convey the meaning or purpose of the values/functions bound to them. Function names specifically usually have names that convey their effect, their behaviour, or the value returned.\nParameter Names for Functions\r#\r\rFunctions take in parameter names — these too can either convey meaning, or be needlessly confusing for human readers.\nThese parameters could also be explained in the docstring, typically placed directly below the function signature.\ndef summing_function(n, func): \u0026#34;\u0026#34;\u0026#34;Sums the result of applying the function func n times from 1 to N. n: int func(n: int): function -\u0026gt; int summing_function -\u0026gt; int \u0026#34;\u0026#34;\u0026#34; total = 0 for i in range(1, n + 1): total += func(i) return total Redundant Code\r#\r\rNames should also be used if a compound expression has been repeated. For example:\nif a == b and b \u0026gt; c: print(a == b and b \u0026gt; c) You can instead store a == b and b \u0026gt; c in a variable, then use that variable for the expressions later. (I understand that the code above is very useless, but it does demonstrate a point)\nresult = a == b and b \u0026gt; c if result: print(result) More Naming Tips\r#\r\rTypically, names with one character are not very helpful in real codes: names should be more descriptive than that. However, there are exceptions:\n n, k, i: Usually used to denote an integer x, y, z: Usually real numbers/coordinates/number inputs for functions f, g, h: Shorthand for function names  Names should be long if they help self-document your code!\nDebugging + Errors\r#\r\rTypes of Errors\r#\r\rThere are different errors in Python, the most common being the following:\n Logic Error Syntax Error Runtime Error  Logic Error\r#\r\rA program has a logic error if the program does not behave as expected. This will not necessarily output something in the console, but can sometimes be discovered as a failing test or a bug report from users. This is why it\u0026rsquo;s important to write doctests for the outputs you expect — you can be sure that the code does not have logic errors.\nOne (very common) example of a logic error is the off-by-one error, where you were off by one in your implementation of a while/for loop.\nSyntax Error\r#\r\rEach programming language has its own syntactic rules. If the rules aren\u0026rsquo;t followed, the program will not necessarily be able to parse the code, thus resulting in code that cannot be executed at all. To fix these syntax errors, use the Python error log in the console to see the traceback message and see which lines they occurred at.\nRuntime Errors\r#\r\rA very common example of a runtime error is the ZeroDivisionError. These errors will happen while a program is running, and in the case of Python, it stops the execution of the program completely.\nTracebacks\r#\r\rWhen reading a Python traceback (which occurs when an error occurs), make sure to look from the bottom to the top. That way, you can see the error that occurred, and the most recent calls before the error happened.\n"},{"id":3,"href":"/docs/week-1/content/introduction/","title":"Introduction to the Basics of Python","section":"Week 1","content":"The first week of CS61A is pretty simple - get used to your coding environment and a few of the basics of Python.\nLab 0\r#\r\rWhile this is optional, it\u0026rsquo;s probably best to do it just to get used to the very basics of Python as well as ok.py, the autograder used in CS61A.\nYou can (and should!) visualize how Python programs works with PyTutor or execute programs with code.cs61a.org, but it\u0026rsquo;s probably better to use something like VSCode instead.\nAlternatively, if you have a bit of experience with other coding languages, you could look at learn X in Y\u0026rsquo;s page which will quickly get you up to speed with the syntax of Python.\n Basics of Python\r#\r\rExpressions + Values\r#\r\r Programs work to manipulate values Expressions in programs evaluate to values Values can have different data types (string, float, boolean, integer, etc.)  Python evaluates these expressions, and then (potentially) displays its values\nData Types\r#\r\r   Data Type Example Values     Integers 2, 44, 25   Floats 3.14, 2.73, 69.69   Booleans True, False   Strings Hi, ben    Operators\r#\r\rThese are pretty self-explanatory\n   Operator Example Expression What it does     + 10 + 2 Adds two values together   - 10 - 2 Subtracts values   * 10*2 Multiplies values   / 10/2 Divides values   // 9//2 Takes the floor of the divided value (result on the left would evaluate to 4)   % 9%2 Takes the remainder of the expression (result on the left would evaluate to 1)   ** 2**2 Finds the value of the left value to the power of the right value    Call Expressions\r#\r\rOftentimes, however, expressions use function calls rather than operators (and the operators above have call function equivalents!)\nFor example, running add(10, 2) does the same thing as 10 + 2 as shown in the example above, but with different form.\nSo the question is: Why use call functions?\nOne possible reason is that call functions are sometimes a lot easier to understand, especially when you have multiple nested call functions (as opposed to multiple mathematical operators)\nA call function always executes the same way with the same procedure, which goes as follows:\nadd(10, 69) add is the operator, 10 and 69 are the operands in this instance.\nPython will first evaluate the operator (and), then will evaluate the operands (10, then 69), then apply the operator (function) to the operands (arguments), in that order, which can be summarized as follows:\n Evaluate the operator  Usually this means check to see if it exists, but the operator itself may be a function in some situations.   Evaluate the operand(s) Apply the operator to the operand(s)  Operators and more commonly, operands can also be written as expressions, so these must be evaluated before step 3 can occur (meaning that if you have any sort of errors in that code block, Python will throw an error!)\nExample of nested expressions\r#\r\rfrom operator import add add(add(3,add(3,2)),add(add(5,4),add(7,6))) While the above example above is very impractical and will not appear in any sort of serious coding, it is a pretty good example of how Python evaluates nested expressions.\nLet\u0026rsquo;s unpack how Python deals with the above expression!\n Python reads from left to right in this expression, so first the add operator will be evaluated Next, the leftmost argument for add will be read, which in this case is the large block add(3,add(3,2)) As this is still another call function, the add will be evaluated, with the operands 3 and add(3,2) 3 is a \u0026lsquo;base case\u0026rsquo;, so that does not need to be further evaluated, but add(3,2) goes through the same procedure, which will then evaluate to 5. Now because the inner add function has been fully evaluated, the value is calculated in reverse order  3 + 5 is calculated, which will return 8 for the first argument.   Same thing happens for the other operand, which will then evaluate to 22 22 and 8 get summed, which will then result in 30  A visual representation (in the form of an expression tree) of what was said above can be seen below.\n Names\r#\r\rA name can be bound to a value. This does not necessarily need to be a variable - it could also be a function or an expression for instance.\nNames are often used because they can be reused in different parts of the code. A name that\u0026rsquo;s bound to a value is known as a variable.\nFor example:\nx = 2 y = 3 print(x + y) # Returns 5 print(x - y) # Returns -1 These values can also change:\nx = 2 print(x) # \u0026gt;\u0026gt;\u0026gt; 2 x = x + 5 print(x) # \u0026gt;\u0026gt;\u0026gt; 7 The equals sign used above is not similar to the one used in mathematics; it is used for assignment rather than equality, which means that you set a value to the variable.\nThis assignment statement works by\n Evaluating the expression on the right of the = Binding the value of the expression to the name on the left side of the =  Environment Diagrams\r#\r\rThese are very useful to visualize how the Python interpreter thinks (and also appear somewhat often in exam questions). PyTutor is a very good resource to generate these environment diagrams if you ever get confused about how assignment works.\nFunctions\r#\r\rFunctions are very useful in programming languages in general because they allow lines of code to be easily reused. Functions, however, are slightly more complicated than variables due to the local and global frames (more on that later).\nWhat is a function?\r#\r\rA function is a sequence of code that can be called on at any point in the program.\nWhile there are built in functions (like the add(a, b) function used earlier), sometimes, they need to be built by hand.\nA function has two portions: an input (the arguments a and b) and an output (a return value). These are not required, but depending on the use case of the function, they are very useful.\nHow do we write a function?\r#\r\rThere are two common methods to write a function in Python, with the most common one being the def statement, which can be written in the format below:\ndef \u0026lt;name\u0026gt;(\u0026lt;parameters\u0026gt;): return \u0026lt;expression\u0026gt; For example, instead of using the built-in add() function from Python, we can create our own by doing the following:\ndef add(a, b): return a + b After the code is defined (e.g. below the function definition), you can then call it:\nadd(5, 6) # \u0026gt;\u0026gt;\u0026gt; 11 In CS61A, the first line is the function signature, and all lines thereafter (there can be more than 1) are considered the function body.\nThe return keyword\r#\r\rIn a Python function statement, the return keyword is vital. What it does is return a value to the place where the function was called, and then exits the function (both properties are very important to remember!)\nThe return keyword acts very differently to print, even if they are in the same function. print does not do any assignment, while return does. The example below may help illustrate my point:\ndef example(x): print(x) return x*2 value = example(3) # Running the above line will print 3 first, then assign 3*2 to value print(value) # \u0026gt;\u0026gt;\u0026gt; 6 Frames\r#\r\rThere are different frames, which you can think of as different rooms in the same house.\nThe global frame is an environment that contains all the variables and functions that were created in the main body of the program.\nA function\u0026rsquo;s local frame is a child of the global frame, where it has its own set of variables that can\u0026rsquo;t be accessed outside the function. For example:\nunhelpful_name = 0 # variable in the global frame def unhelpful_function(unhelpful_name): # variable in the local frame (even though it has the same name it isn\u0026#39;t the same variable) return unhelpful_name # \u0026gt;\u0026gt;\u0026gt; 2 # The above will return 2 as opposed to 0 because the unhelpful_name variable called in the function is the one passed into the function. unhelpful_function(2) Name Lookup Rules\r#\r\rPython looks up names in a user-defined function using the following logic:\n Look it up in the local frame If the name is not in the local frame, look for the name in the parent frame If the name is not in any searched frame, throw a NameError.   Ending Notes\r#\r\rIf you don\u0026rsquo;t understand any of this, it is very important to ask for more help, whether that be from your peers or from your TAs, or even searching on the internet. Another very useful resource (especially for understanding how frames work) is PyTutor. Please use it.\n"},{"id":4,"href":"/docs/week-4/content/recursion/","title":"Recursion","section":"Week 4","content":"Recursion\r#\r\rRecursive Functions\r#\r\rA function is recursive if the body of the function calls itself (either directly or indirectly).\nRecursive functions pretty much always lead to a base case by operating on increasingly smaller instances of the problem. A base case is the simplest case possible where a calculation can actually be done.\nFor example, a recursive function to sum the digits in a number can be written as below:\ndef sum_digits(n): assert n \u0026gt;= 0 if n \u0026lt; 10: # Base case, only happens when there\u0026#39;s 1 remaining digit return n return sum_digits(n // 10) + n % 10 # Adds the rest of the number with the final number # sum_digits(n // 10) just calls the sum_digits function again but with a simpler case in this case. Another example is a factorial function:\ndef factorial(n): assert n \u0026gt;= 0 if n == 1 or n == 0: return 1 else: n * factorial(n - 1) If you notice how factorial works, it repeatedly multiplies n with a value one lower than itself, which allows the recursive function above to work.\nAs a result, the anatomy of a recursive function can be broken down into the following components:\n Base Case: The smallest sub-problem Recursive Case: Breaking down a problem into a smaller sub-problem Conditional Statement: Decides whether something is a base case or a recursive case.  Recursion in Environment Diagrams\r#\r\rIf we use the same factorial function from above, calling factorial(3) on it, we can visualize the function calls in the environment diagram below in two steps — first reaching the base case, then evaluating the result.\n\rmermaid.initialize({\r\"flowchart\": {\r\"useMaxWidth\":true\r},\r\"theme\": \"dark\"\r}\r)\rgraph LR;\rsubgraph \"f3: factorial(x) [parent = Global]\"\rf3-n[n] --- f3-1[1]\rf3-rv[Return Value] --- f3-r[1]\rend\rsubgraph \"f2: factorial(x) [parent = Global]\"\rf2-n[n] --- f2-3[2]\rf2-rv[Return Value] --- f2-r[\"2 * (factorial(1))\"]\rend\rsubgraph \"f1: factorial(x) [parent = Global]\"\rf1-n[n] --- f1-3[3]\rf1-rv[Return Value] --- f1-r[\"3 * (factorial(2))\"]\rend\rsubgraph Global Frame\rfactorial -- factorial_fucntion[\"func factorial(n) [parent = Global]\"]\rend\rAfter the base case is reached, each return value in the stack can be evaluated:\ngraph LR;\rsubgraph \"f3: factorial(x) [parent = Global]\"\rf3-n[n] --- f3-1[1]\rf3-rv[Return Value] --- f3-r[1]\rend\rsubgraph \"f2: factorial(x) [parent = Global]\"\rf2-n[n] --- f2-3[2]\rf2-rv[Return Value] --- f2-r[\"2 * 1 = 2\"]\rend\rsubgraph \"f1: factorial(x) [parent = Global]\"\rf1-n[n] --- f1-3[3]\rf1-rv[Return Value] --- f1-r[\"3 * 2 = 6\"]\rend\rsubgraph Global Frame\rfactorial -- factorial_fucntion[\"func factorial(n) [parent = Global]\"]\rend\rAs a result, we can visualize a recursive call almost like that of a stack. The values keep reducing to a simpler case until a base case is reached, and when that happens, the result for each recursive call (starting from the base case) is then evaluated, which then will combine to evaluate to the final result.\nVerifying Recursive Functions\r#\r\rDomino Example\r#\r\rLet\u0026rsquo;s use an example to illustrate how designing/verifying a recursive function can work.\nTake for example that you had a line of a thousand equally spaced dominoes, and you wanted to test whether tipping one would tip all of them, you could just see if 1 domino would fall if tipped, then assume that any domino will tip the next one, then verify that tipping the first domino tips the next one.\nThis can be generalized with two different methods:\nRecursive Leap of Faith\r#\r\rSteps:\n Verify the base case — make sure it\u0026rsquo;s functional and works properly Assume that a simplified case of the function is correct (← leap of faith) Verify that the function itself returns the simplified function calls correctly  For a more concrete example, take the factorial function from above:\n Verify that return 1 if n == 0 or n == 1 is the correct base case Assume that factorial(n - 1) returns the correct value Verify that n * factorial(n - 1) is the correct statement  Recursive Cat\u0026rsquo;s Promise\r#\r\rWhile this usually isn\u0026rsquo;t a cat\u0026rsquo;s promise, but rather an elf, I like cats, so I\u0026rsquo;m going to go with cats.\nWith this perspective, the recursive cat handles the simplified recursive call, and promises that they will calculate the smaller recursive call for you while you handle the rest.\nFor example, to calculate 3!, you would ask yourself how you could calculate 3! if you knew the value of 2!, which in this case, is simply 3 * 2! — as a result, you do! Then, the recursive cat promises to handle the result of factorial(2) for you. (The recursive cat then calls on itself to find the value of factorial(1), but you do not need to know that to be able to solve factorial(5) — all you need is the value of factorial(4))\nMutual Recursion\r#\r\rWhen recursive functions are defined in terms of each other, the functions are mutually recursive.\nFor example, we can have this (useless) function that determines whether a number is even or odd in a mutually recursive manner:\ndef even(n): if n == 0: return True else: return odd(n - 1) def odd(n): if n == 0: return False else: return even(n - 1) print(even(4)) # True Note:\nMutually recursive functions can be written as a single recursive function by simply breaking the abstraction boundary between the two functions. For example, the code above can be written in the following manner:\ndef even(n): if n == 0: return True else: if (n - 1) == 0: return False return even((n - 1) - 1) As you can see, the code checks whether a number is even initially, then checks for the odd case and thus, deals with 2 digits in 1 go. However, this implementation is far more convoluted than the mutually recursive version (and you can imagine how much more complex this would be with more complexity), so using a mutually recursive solution can simply be a mechanism for keeping your code simple; in other words: maintaining abstraction.\n\rA good indicator of when a mutual recursive solution could be used is when there is a natural recursive solution, but there is more than 1 case that needs to be checked for (in the above example, whether the number was even or odd)\nRecursion + Iteration\r#\r\rConverting Recursion to Iteration\r#\r\rFirst, you must figure out what state needs to be maintained by the iterative function that the recursive function would store itself. For example, in the factorial function, the recursive function works by multiplying n with a simpler version of the factorial function, meaning that the iterative version would need something to store n and multiply it with n - 1 until a \u0026lsquo;base case\u0026rsquo; is reached.\nFor instance:\ndef recursive_factorial(n): assert n \u0026gt;= 0 if n == 1 or n == 0: return 1 else: return n * recursive_factorial(n - 1) def iterative_factorial(n): k = n - 1 while k \u0026gt; 0: # \u0026#39;Base Case\u0026#39; n = n * k # Does the multiplication k = k - 1 # Decrements n, similar to recursive_factorial(n - 1) return k Converting Iteration to Recursion\r#\r\rConverting iteration to recursion is sometimes easier than doing it the other way around. Essentially, the state of an iteration can be passed in as arguments to the recursive function:\ndef iterative_sum_digits(n): total = 0 while n \u0026gt;= 10: digit_sum = digit_sum + n % 10 #  n = n // 10 return total def recursive_sum_digits(n, total): if n \u0026lt; 10: return n else: return(n // 10, total + n % 10) # Iterative variables passed as arguments for the recursive version Helper Functions\r#\r\rIf a recursive function ever needs to keep track of more variables than the original function provides, you probably need a helper function for that.\ndef is_prime(n): \u0026#39;\u0026#39;\u0026#39;Returns True if n is a prime number, else returns False \u0026gt;\u0026gt;\u0026gt; is_prime(13) True \u0026gt;\u0026gt;\u0026gt; is_prime(14) False \u0026gt;\u0026gt;\u0026gt; is_prime(2) True \u0026#39;\u0026#39;\u0026#39; assert n \u0026gt;= 2 def helper(i): if i == n: return True elif n % i == 0: return False else: return helper(i + 1) return helper(2) "},{"id":5,"href":"/docs/week-4/content/tree-recursion/","title":"Tree Recursion","section":"Week 4","content":"Tree Recursion\r#\r\rOrder of Recursive Calls\r#\r\rIf you know the behaviour of environment diagrams, you could derive the behaviour of recursive calls.\nRecaling how environment diagrams behave, a new frame is opened when a user-defined function call occurs, meaning that whenever a recursive function is called on a non-base case scenario, a new frame is opened, and that frame will be evaluated.\nAs a result, in a tree recursive return value (more on that later), for example recursive(3) + recursive(4), the whole value of recursive(3) is evaluated first before recursive(4) is evaluated (due to the order of operations of Python).\nTree Recursion\r#\r\rTree recursion occurs when a recursive function makes more than one recursive call, thus creating a sort of network of sorts of recursive calls that is sort of shaped like the roots of a tree.\nFibonacci Numbers\r#\r\rdef fib(n): if n \u0026lt;= 0: return 0 elif n == 1: return 1 return fib(n - 1) + fib (n - 2) fib(3) As you can see in the example above, the recursive call returns two instances of the same function, thus creating a structure that calls itself multiple times in a sort of tree-like fashion (as seen in the image below)\nNotice how this is pretty inefficient though! There are multiple calls to fib(1), so that function would need to be evaluated multiple times (and this redundant execution would get executed more if we started with fib(4) for instance). There are ways to alleviate this (to a certain extent), but\nCounting Partitions\r#\r\rThe solution to this classic tree recursion problem has a structure that can be used in other tree recursive problems — it\u0026rsquo;s worth truly understanding how it works.\nThe question is defined as follows:\nCount the number of possible partitions with positive integers n, using parts up to size m.\nThis problem has two distinct parts, one part calculating the possibilities with the current size m, and the other part calculating the possibilities with smaller part sizes m - 1 in a recursive manner.\nFor example, for count_partitions(4, 3), you could have the following outcomes:\n3 1\r2 2\r2 1 1\r1 1 1 1\rWhich would return 4 as those are the total number of possibilities. Each line break represents a different path for the recursive solution.\nIn general, the recursive call can be generalized as follows count_partitions(n - m, m) + count_partitions(n, m - 1) which essentially is adding up the recursive function for the case where m is used, and the case where m is not used. After we have this logic, we just need to come up with the base cases, and assume that our recursive solution will work.\nFor our base cases, we know that if n is ever negative, there will be no possible results, and if m is equal to 0, it will not be possible to create any partitions of size n (other than 0). For n = 0, you can create 1 total partition by using partition size 0 (which is still less than m).\nAs a result, the code can be written as follows:\ndef count_partitions(n, m): if n == 0: return 1 elif n \u0026lt; 0 or m == 0: return 0 return count_partitions(n - m, m) + count_partitions(n, m - 1) "},{"id":6,"href":"/docs/week-6/content/trees/","title":"Trees","section":"Week 6","content":"Trees\r#\r\rA tree is an abstract data structure (basically not implemented by default in Python), which means we need to use data abstractions in order to implement this structure.\nWhat does a tree look like?\r#\r\rA tree has a root and a list of branches, where each branch is a tree itself.\nA tree with zero branches (the white circles in the drawing above) is called a leaf. A tree also starts at the root, which in the drawing above, is the blue circle.\nWhile this may not look like a tree, but rather roots of the tree itself, you could potentially think of the drawing as an upside down tree.\r\rAlso notice how when we look at the branches stemming from the root, we have two separate sub-trees? This means that recursion will be a common way to go about solving tree-related problems.\n Each location in a tree can be called a node, and each node has a label which contains the value located within the node (can be any value). Nodes can be parents/children of each other, and the top node is the root node.\nTree Data Abstraction\r#\r\rThere are many possible data abstraction for trees, but the one that CS61A uses is the following:\n   Abstraction Description     tree(label, branches = []) Returns a tree with root label and a list of branches   label(tree) Returns the label of the tree   branches(tree) Returns the branches of the tree (in a list) — each of which is a tree by itself   is_leaf(tree) Returns True if the current node is a leaf node.    For example, a tree could be the following:\nt = tree(3, # Root Node # Branches: [tree(2, [tree(1)], # Left Branch tree(4))] # Right Branch ) The actual implementation of the tree is information that you do not need to know in order to use this data structure, so I will not write the implementation here. The documentation for these data abstractions says that branches(tree) returns a list, meaning that calling branches(tree)[0] is not a violation of data abstraction here.\n"},{"id":7,"href":"/docs/week-3/content/decorators/","title":"Decorators","section":"Week 3","content":"Decorators\r#\r\rPython decorators allow you to wrap functions inside one another easily. These may not be seen that often in the CS61A course, but in general, are pretty good to know due to the simplicity that it has as well as the common usage of it in web frameworks such as Flask, or in larger codebases.\nExample Usage\r#\r\rLet\u0026rsquo;s take this trace function for example:\nIt returns a function that takes a single argument which traces the inputs and outputs of each function.\ndef trace1(f): def traced(x): print(f\u0026#34;Input: {x}\u0026#34;) result = f(x) print(f\u0026#34;Output: {result}\u0026#34;) return result return traced If we wanted to trace abs(-4) using trace1, we would call trace1(abs)(-4) to get an output in the console of:\n\u0026#39;\u0026#39;\u0026#39; \u0026gt;\u0026gt;\u0026gt; trace1(abs)(-4) Input: -4 Output: 4 \u0026#39;\u0026#39;\u0026#39; You could also use it in the following way if you wanted the trace function to be called on every instance of a function being called:\ndef square(x): return x*x square = trace1(square) The code above would then make sure the trace1 function is wrapped around every square call, meaning that when square is called, trace1 is always used.\nHowever, there is a shorthand way of doing the above, which is to use a decorator:\n@trace1 def square(x): return x*x "},{"id":8,"href":"/docs/week-2/content/higher-order-functions/","title":"Higher Order Functions","section":"Week 2","content":"Higher Order Functions\r#\r\rDesigning Functions\r#\r\rDescribing Functions\r#\r\r   Aspect Example     The domain of a function is the expected range of inputs (similarly to a domain in mathematics) x is a string.   The range of a function is the set of output values that could be returned Function square returns a non-negative number.   The behavior of a (pure) function is the relationship between the input and the output Function square returns the square of an input x.    Don\u0026rsquo;t Repeat Yourself!\r#\r\rWhen making a function, give each function exactly one job, but allow it to be flexible to apply to many related situations. Doing this allows you to remove redundant code and make your code clearer to read, and easier to write.\nGeneralization\r#\r\rIf you see a common structure, you can refactor your code to move the redundant code to a function and call that instead.\nFor example, if we take this code block below:\ndef print_ben_if_positive(n): if n \u0026gt; 0: print(\u0026#34;ben\u0026#34;) def print_ben_if_positive(n): if n \u0026gt; 0: print(\u0026#34;tao\u0026#34;) We can see that the if statement is duplicated, so we can take that logic to another function instead, removing redundant code.\ndef positive_print(number, message): if number \u0026gt; 0: print(message) positive_print(n, \u0026#34;ben\u0026#34;) positive_print(n, \u0026#34;tao\u0026#34;) Higher-order Functions\r#\r\rA higher-order function is a function that takes another function as an argument, or returns a function as its result.\nFunctions as Arguments\r#\r\rA function can take another function as an argument.\nfrom operator import add, sub def function_in_function(adding_function, x, y): return adding_function(x, y) function_in_function(add, 3, 2) # \u0026gt;\u0026gt;\u0026gt; 5 function_in_function(sub, 3, 2) # \u0026gt;\u0026gt;\u0026gt; 1 In the example above, we passed the add and sub functions to the function function_in_function. This is an example of a higher order function.\nNote that in the call functions themselves, add and sub were called rather than add() and sub(). This is because of how call functions are evaluated. Running add() directly will make the Python interpreter try to evaluate the function itself with no parameters, which would not work, while simply typing add will allow function_in_function to evaluate add() with the proper parameters.\r\rFunctions as Return Values\r#\r\rAnother way to have a higher order function is to return a function.\nFunctions created in other functions are bound to names in their local frame, allowing for cleaner naming when creating function calls. For example:\ndef make_adder(magnitude): def adder(n): return n + magnitude return adder add_two = make_adder(2) add_three = make_adder(3) print(add_two(2), add_three(2)) # \u0026gt;\u0026gt;\u0026gt; 4 5 While the example above may not have much practical use, it shows the process of returning a function within a function, making this another higher order function. Take your time to digest how the above two examples work. This will be harder to conceptualize at the beginning.\nCall Expressions as operator expressions\r#\r\rYou can run a function like make_adder(2)(3) which will return 5. Why is that? Let\u0026rsquo;s look at how the call function order works.\n make_adder(2) is first evaluated, which returns a function adder similarly to the function above. Due to adder being returned from the operator, the final statement will end up being adder(3), leading to 5 being the final output  Lambda Expressions\r#\r\rLambda expressions pretty much work the same way as regular functions, other than the fact that these functions are anonymous - they do not have a name assigned to it.\nThe syntax looks like the following:\nlambda \u0026lt;parameters\u0026gt;: \u0026lt;expression\u0026gt; For instance:\ndouble = lambda x: y*2 double(3) # \u0026gt;\u0026gt;\u0026gt; 6 While this may not seem very useful in this context, there are quite a few uses for it. The main idea is that lambda functions are better suited for functions that you want to access in the short term, or only access once.\nA lambda function does not contain any statements at all, including if statements and return statements.\nFor instance, instead of doing\nfrom operator import add def square(x): return x**2 add(2, square(2)) You can do the following:\nfrom operator import add add(2, lambda x: x**2) Conditional Expressions\r#\r\rlambda functions not allowing statements can be quite limiting, but that is where conditional expressions come in.\nA conditional expression has a form that almost reads like English:\n\u0026lt;do this (true)\u0026gt; if \u0026lt;condition\u0026gt; else \u0026lt;do this (false)\u0026gt; This may be strange if you\u0026rsquo;re used to ternary operators in other languages (for example JavaScript) as the order of reading the Python statement may be a bit strange.\nHowever, the operation order is the following:\n Check the truthiness of \u0026lt;condition\u0026gt; If true, evaluate \u0026lt;do this (true)\u0026gt; Else, evaluate \u0026lt;do this (false)\u0026gt;  In conjunction with lambda functions, you can do the following:\nlambda x: x if x \u0026gt; 0 else 0 The code block above returns the input if it is positive, else returns 0.\n"},{"id":9,"href":"/docs/week-6/content/mutability/","title":"Mutability","section":"Week 6","content":"Mutability\r#\r\r"},{"id":10,"href":"/docs/week-5/content/sequences/","title":"Sequences","section":"Week 5","content":"Sequences\r#\r\rLists in Environment Diagrams\r#\r\rLists can represented with box and pointer notation (similarly to functions); however, unlike functions, each element in the array has its own box, and is index labelled.\nWhat this implies is that assigning a variable to another list will not create a copy of that list, but rather point towards the same list — this ends up being a correct assumption to make.\nEach box can either hold a value (for example a number or a string), or an object (for example, a function, another list, or a Class).\nList Slicing\r#\r\rSlicing a list creates a new list (as in it points to a separate list). The behaviour is very similar to the range() function — it starts on the first \u0026lsquo;argument\u0026rsquo; provided, ends on the number right before the second \u0026lsquo;argument\u0026rsquo;, with step of the third \u0026lsquo;argument\u0026rsquo;. In this case however, the separator is : rather than ,. If there is no argument provided next to the :, it defaults to 0.\nThe syntax is lst[\u0026lt;start\u0026gt;:\u0026lt;end\u0026gt;:\u0026lt;step_size\u0026gt;]\nBelow are some examples:\nlst = [1, 2, \u0026#34;bananas\u0026#34;] lst[0:] # [1, 2, \u0026#34;bananas\u0026#34;] lst[:2] # [1, 2] lst[1:] # [2, \u0026#34;bananas\u0026#34;] lst[::2] # [1, \u0026#34;bananas\u0026#34;] This behaviour also works with strings:\nstring = \u0026#34;benbaron\u0026#34; string[3:] # \u0026#34;baron\u0026#34; string[:3] # \u0026#34;ben\u0026#34; Small Practice Problems\r#\r\rRecursion in Lists\r#\r\rImagine summing the numbers in a list but using recursion rather than iteration or the sum() function.\ndef sum_numbers(lst): \u0026#39;\u0026#39;\u0026#39;Returns the sum of the numbers in lst \u0026gt;\u0026gt;\u0026gt; sum_numbers([2, 3, 4]) 9 \u0026#39;\u0026#39;\u0026#39; We could implement the function above using list comprehension:\ndef sum_numbers(lst): \u0026#39;\u0026#39;\u0026#39;Returns the sum of the numbers in lst \u0026gt;\u0026gt;\u0026gt; sum_numbers([2, 3, 4]) 9 \u0026#39;\u0026#39;\u0026#39; if lst == []: # base case return 0 else: return lst[0] + sum_numbers(lst[1:]) # takes the first number and  # recursively calls the function on a smaller list. Reversing a String (Recursively)\r#\r\rdef reverse_string(word): \u0026#39;\u0026#39;\u0026#39;Reverse the string provided in word \u0026gt;\u0026gt;\u0026gt; reverse_string(\u0026#34;ben\u0026#34;) neb \u0026#39;\u0026#39;\u0026#39; Our base case here would be when the word provided is an empty string.\ndef reverse_string(word): \u0026#39;\u0026#39;\u0026#39;Reverse the string provided in word \u0026gt;\u0026gt;\u0026gt; reverse_string(\u0026#34;ben\u0026#34;) neb \u0026#39;\u0026#39;\u0026#39; if word == \u0026#34;\u0026#34;: return \u0026#34;\u0026#34; else: return reverse_string(word[1:]) + word[0] # keep in mind the order of the operation above matters # word[0] is put afterwards because # that should be added up later Built-in functions for Iterables\r#\r\r   Function Description     sum(iterable, start) Returns the sum of the values in iterable, with a starting sum of start (defaults to 0)   all(iterable) Returns True if all the values of iterable are Truthy values (or if the iterable is empty), else returns False   any(iterable) Returns True if any of the values of iterable are Truthy, else returns False   max(iterable, key=None) Returns the maximum value in iterable   min(iterable, key=None) Returns the minimum value in iterable    Examples of the built-in functions\r#\r\rsum([3, 2, 1], 50) # 56 any([True, False, False, False]) # True any([3, 2, 1, 0]) # True all([3, 2, 1]) # True all([True, False, False, False]) # False max([3, 2, 1]) # 3 max([\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]) # \u0026#34;c\u0026#34; max(range(10)) # 9 # the \u0026#39;key\u0026#39; parameter can be used to compare certain elements in an array: coords = [[1, 2], [4, 3], [3, 90]] max(coords, key = lambda x: x[0]) # [4, 3] (x iterates through coords and then checks the max value of the first element) "},{"id":11,"href":"/docs/week-5/content/data-abstraction/","title":"Data Abstraction + Dictionaries","section":"Week 5","content":"Data Abstraction\r#\r\rMany values in programs are compound values — a value composed of multiple values (for example coordinates, dates, or geographic positions)\nBy using a data abstraction, you can manipulate compound values as units without needing to worry about the way that values are stored.\nPair Abstraction\r#\r\rFor data that is stored in pairs, we can manipulate these values using a pair data abstraction:\ncouple = pair(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;) a = first(couple) b = second(couple) By implementing pair() (our constructor), first(), and second() (the selectors), you can access these elements without needing to worry about how the data is stored. The only time that people need to worry about how the data is stored is when implementing the functions themselves. One example (implying that there are multiple ways) of implementing these functions can be seen below:\ncouple = lambda a, b: [a, b] first = lambda lst: lst[0] second = lambda lst: lst[1] Rational Numbers\r#\r\rOne reasonable data abstraction to do is to implement rational numbers as a data abstraction. By storing the numerator and denominator separately, we can get precise values of certain fractions such as 1/3.\nFor example:\nhalf = rational(1, 2) top = numerator(half) # 1 bottom = denominator(half) # 2 We have the structure for a denominator\u0026hellip; cool I guess? But at its current state, we can\u0026rsquo;t do anything with the numbers in terms of multiplying/adding/printing them in the way that we expect. As a result, we can write more functions to help us do that using functions.\ndef mul_rational(x, y): return rational( numerator(x) * numerator(y), denominator(x) * denominator(y) ) def add_rational(x, y): nx, dx = numerator(x), denominator(x) ny, dy = numerator(y), denominator(y) return rational( nx * dy + ny * dx, dx * dy ) Notice how at this point we still do not know how rational() is implemented.\nImplementation\r#\r\rdef rational(n, d): return [n, d] def numerator(rational): return rational[0] def denominator(rational): return rational[1] However, rational(n, d) doesn\u0026rsquo;t fully simplify the fractions, so to solve that, we can divide both n and d by the greatest common denominator:\ndef rational(n, d): g = gcd(n, d) return [n // g, d // g] Layers of Abstraction\r#\r\rYou might be wondering, what\u0026rsquo;s the point of data abstraction?\nOne reason is that some things are a lot harder to code/understand (in terms of legibility) without using data abstraction in Python (for example coding a tree), but the main reason is for simplicity and extensibility.\nWhat data abstraction does is allow changing the implementation of the function itself without actually needing to manually change all the instances of it. In addition, with a good data abstraction, the programmer will not need to know how the data is implemented, but just needs to use the constructors and selectors to do the job for them.\nAbstraction Barriers\r#\r\r   Layer Examples     Representation/Implementation [x, y], [0], [1]   Data Abstraction 1 make_rational, numerator, denominator   Data Abstraction 2 mul_rational, add_rational   User Programs Could be anything using the layer above    Each layer would only need to use the layer above it, meaning that when users use the data abstractions, they do not need to care about how it\u0026rsquo;s implemented.\nHowever, this requires that the abstraction barriers are not violated. For example, if you were to do:\nadd_rational([1, 2], [3, 4]) You would be violating the abstraction barrier. This would not work if the implementation of rational were changed for instance. As a result, make sure to use both the constructors and the selectors instead of assuming what the implementation is.\nDictionaries\r#\r\rA dictionary is another way to store multiple pieces of data, however, it is stored differently to that of lists, and is also accessed slightly differently.\nEach element in a dictionary stores a key and a value as a pair, with each element separated by a , (similarly to lists) which looks like the following below:\nmy_fruits = {\u0026#34;apples\u0026#34;: 2, \u0026#34;bananas\u0026#34;: 25} If we had the following dictionary, we could call my_fruits[\u0026quot;apples] to get the value of apples, which in this case would return 2. If we wanted to edit the amount of apples we had, we would then assign a value to the index: myfruits[\u0026quot;apples\u0026quot;] = 3 would mutate our dictionary that we have.\nQueries\r#\r\r\u0026gt;\u0026gt;\u0026gt; \u0026#34;apples\u0026#34; in my_fruits # able to search for keys True \u0026gt;\u0026gt;\u0026gt; 2 in my_fruits # not able to search for values False \u0026gt;\u0026gt;\u0026gt; len(my_fruits) 2 Rules\r#\r\rkeys cannot be a list or a dictionary (or any mutable type). However, values can be of any types (including dictionaries).\nThere can only be one value mapped to every key (similarly to mathematical functions)\nIteration\r#\r\rfor fruit in my_fruits: print(fruit, my_fruits[fruit]) # apples 2 # bananas 25 Notice that fruit iterates through the keys and not the values!\r\rDictionary Comprehensions\r#\r\rVery similar to list comprehensions, but it uses {} instead of []; in the form of {\u0026lt;key\u0026gt;: \u0026lt;value\u0026gt; for x in \u0026lt;iter\u0026gt;}.\n{x: x*x for x in [1, 2, 3, 4]} # would return a dictionary of  { 1: 1, 2: 4, 3: 9, 4: 16 } "},{"id":12,"href":"/docs/week-2/content/environment/","title":"Environment Diagrams","section":"Week 2","content":"Environment Diagrams\r#\r\rEnvironment Diagrams are a good way to visualize how Python deals with its execution, and can also help you to visualize how more complicated pieces of code (e.g. Higher Order Functions) work.\nPyTutor has a way of converting from code to environment diagrams, so please use that as a resource! The diagrams below are not going to match those from PyTutor exactly due to Markdown constraints, but I will try to emulate them as well as possible.\nVariable Assignment\r#\r\rx = 2 y = 5 When the code block above is run, the value 2 will be assigned to the name x, and afterwards, the value 5 will be assigned to the name y, which can be seen in an environment diagram like the one below:\n\rmermaid.initialize({\r\"flowchart\": {\r\"useMaxWidth\":true\r},\r\"theme\": \"dark\"\r}\r)\rgraph LR;\rsubgraph Global Frame\rx --- 2\ry --- 5\rend\rIn each frame, there can only be one name bound to one value - it is not possible to have one name point to two different values.\nFunction Assignment\r#\r\rFunctions are notated differently to variables due to the potential need to overwrite a binding without losing the value of a function somewhere else (will make sense later).\ndef square(n): return n*n square(3) This will be executed in two different steps: creating the function, then executing the function.\ndef square(n): return n*n \rgraph LR;\rsubgraph Global Frame\rsquare -- id1[\"func square(x) [parent = Global]\"]\rend\rsquare(3) When a function is called, a new frame is created, leading to another environment for Python to execute code from. Note that an environment variable only needs the function name, parameter(s), and parent frame in the environment diagram.\ngraph LR;\rsubgraph Global Frame\rsquare -- id1[\"func square(x) [parent = Global]\"]\rend\rsubgraph \"f1: square [parent = Global]\"\rn --- 3\rid2[Return Value] --- 9\rend As can be seen in the environment diagram above, a new unique frame f1 is created, which has all the passed in parameters (in this case, just n = 3) stored. Then, when the return statement is reached, it simply evaluates the right side of the return statement (in this case n*n), then returns that value (9)\nConfusing Function Assignment Example\r#\r\r(Taken from Fall 2021 Discussion 1)\ndef double(x): return x * 2 def triple(x): return x * 3 hat = double double = triple The functions double and triple\u0026rsquo;s environment diagrams are pretty self-explanatory, but the next two statements hat = double and double = triple are slightly more confusing. Let\u0026rsquo;s break it down:\ngraph LR;\rsubgraph Global Frame\rdouble -- double_function[\"func double(x) [parent = Global]\"]\rtriple -- triple_function[\"func triple(x) [parent = Global]\"]\rend\rWhat would happen with hat? In this case, it points to the function double(x) rather than the name double itself. This means that hat becomes a copy of double rather than acting as double. Take a look at the environment diagram below:\ngraph LR;\rsubgraph Global Frame\rdouble -- double_function[\"func double(x) [parent = Global]\"]\rtriple -- triple_function[\"func triple(x) [parent = Global]\"]\rhat -- double_function\rend\rBoth double and hat point to the same function double(x)!\nNow, what would happen with double = triple? You can simply extrapolate the actions above, but quite simply, the pointers change.\ngraph LR;\rsubgraph Global Frame\rdouble -- triple_function\rtriple -- triple_function[\"func triple(x) [parent = Global]\"]\rhat -- double_function[\"func double(x) [parent = Global]\"]\rend\rThis means that you can still call the double(x) function through hat, but you can no longer call it through double. Additionally, even when double was overwritten, the function double(x) itself was not deleted!\nCall Expressions\r#\r\rThe important thing to note is that when executing call expressions, a new frame is created to keep track of local variables. The order of operations is as follows:\n Evaluate the operator - this should evaluate to a function. Evaluate the operands from left to right. Make a new frame with:  A unique index The real name of the function (not the name of the variable pointing to it) (for example, for double(n)) The parent frame   Bind values to names in this new frame. Evaluate the function in this new frame until a return value is obtained.  Example from Fall 2021 Discussion 1:\ndef double(x): return x * 2 hmmm = double wow = double(3) hmmm(wow) \rgraph LR;\rsubgraph Global Frame\rdouble -- double_function[\"func double(x) [parent = Global]\"]\rhmm -- double_function\rend\rAfter the function double(x) is bound to a name, and hmm is bound to that function, we create a new frame to evaluate wow = double(3).\nWhen evaluating that statement, the right side is evaluated before being assigned to the name on the left side. As a result, wow will not appear in the environment diagram until after the return value is created.\ngraph LR;\rsubgraph Global Frame\rdouble -- double_function[\"func double(x) [parent = Global]\"]\rhmm -- double_function\rwow -- \"(After the return value below is evaluated)\" --- outer[6]\rend\rsubgraph \"f1: double(x) [parent = Global]\"\rx --- 3\rreturn[Return Value] --- 6\rend\rAfterwards, hmmm(wow) is called, which is essentially the same thing as doing hmmm(6). As hmmm is pointing to func double(x) [parent = Global], it will run that function, passing in the parameter 6. However, because this is a new function, a new frame will be created.\ngraph LR;\rsubgraph Global Frame\rdouble -- double_function[\"func double(x) [parent = Global]\"]\rhmm -- double_function\rwow -- \"(After the return value below is evaluated)\" --- outer[6]\rend\rsubgraph \"f1: double(x) [parent = Global]\"\rx --- 3\rreturn[Return Value] --- 6\rend\rsubgraph \"f2: double(x) [parent = Global]\"\rf2-x[x] --- f2-6[6]\rf2-return[Return Value] --- f2-return-value[12]\rend\rNested Call Expression\r#\r\rEnvironment diagrams can also help visualize how to deal with nested call expressions.\nFor example:\ndef double(x): return x*2 result = double(double(2)) How would this look in an environment diagram?\nFirst, the inner double(2) gets evaluated, so a frame is created for that, then the return value from that is used in the outer function, so another frame is created for that.\ngraph LR;\rsubgraph Global Frame\rdouble -- double_function[\"func double(x) [parent = Global]\"]\rend\rsubgraph \"f1: double(x) [parent = Global]\"\rf1-x[x] --- f1-2[2]\rf1-rv[Return Value] --- f1-r[4]\rend\rAfter the inner function is evaluated, the return value is then passed into the function to be run again in another frame:\ngraph LR;\rsubgraph Global Frame\rdouble -- double_function[\"func double(x) [parent = Global]\"]\rend\rsubgraph \"f1: double(x) [parent = Global]\"\rf1-x[x] --- f1-2[2]\rf1-rv[Return Value] --- f1-r[4]\rend\rsubgraph \"f2: double(x) [parent = Global]\"\rf2-x[x] --- f2-4[4]\rf2-rv[Return Value] --- f2-r[8]\rend\rNote: Both of the parents of the function are the global frame because the function itself is called, and that is located inside the parent frame.\r\rNames in Environments\r#\r\rNames have different meanings in different environments!\ndef double(double): return double + double double(2) Please do not write code like this. It is merely a demonstration of how names and environments interact.\ngraph LR;\rsubgraph Global Frame\rglobal_double[double] -- glob_double_function[\"func double(double) [parent = Global]\"]\rend\rsubgraph \"f1: double(double) [parent = Global]\"\rf1_double[double] --- 2\rf1_r[Return Value] --- 4\rend\rNotice how the different environment frames allow for the name double to exist twice with different assignments.\nEnvironment Diagrams for Higher-order Functions\r#\r\rNote that functions are first class in Python - they act the same as values.\nHOF: Takes a function as an argument\r#\r\rdef run_twice(func, *args): return func(func(*args)) def double(x): return x*2 double_double = run_twice(double(2)) What *args does here is simply allow for a flexible number of arguments to be passed in rather than a set number - allows for more flexibility even though it doesn\u0026rsquo;t do much here.\ngraph LR;\rsubgraph Global Frame\rglobal_run_twice[run_twice] -- global_run_twice_function[\"func run_twice(func, *args) [parent = Global]\"]\rglobal_double[double] -- global_double_function[\"func double(x) [parent = Global]\"]\rend\rAfter assigning the functions to the names, we get the environment diagram seen above. To evaluate double_double = run_twice(double(2)), you have to remember the order of operations for call functions. First, evaluate the operators (make sure it exists/is not a higher order function), then evaluate the operands, then apply the operator to the operands.\nIn this context it means that run_twice is evaluated first with the proper pointers, then double is run after that is done.\ngraph LR;\rsubgraph Global Frame\rglobal_run_twice[run_twice] -- global_run_twice_function[\"func run_twice(func, *args) [parent = Global]\"]\rglobal_double[double] -- global_double_function[\"func double(x) [parent = Global]\"]\rend\rsubgraph \"f1: run_twice(func, *args) [parent = Global]\"\rf1_func[func] -- global_double_function\rf1_args[args] --- 3\rend\rsubgraph \"f2: double(x) [parent = Global]\"\rf2_x[x] --- f2_3[3]\rf2_r[Return Value] --- 6\rend\rAfterwards, we get the following:\ngraph LR;\rsubgraph Global Frame\rglobal_run_twice[run_twice] -- global_run_twice_function[\"func run_twice(func, *args) [parent = Global]\"]\rglobal_double[double] -- global_double_function[\"func double(x) [parent = Global]\"]\rglobal_double_double[double_double] --- global_12[12]\rend\rsubgraph \"f1: run_twice(func, *args) [parent = Global]\"\rf1_func[func] -- global_double_function\rf1_args[args] --- 3\rf1_r[Return Value] -- \"(Only after f3's return value is evaluated)\" --- f1_rv[12]\rend\rsubgraph \"f2: double(x) [parent = Global]\"\rf2_x[x] --- f2_3[3]\rf2_r[Return Value] --- 6\rend\rsubgraph \"f3: double(x) [parent = Global]\"\rf3_x[x] --- f3-6[6]\rf3_r[Return Value] --- f3_rv[12]\rend\rThese environment diagrams do get somewhat complicated.\nHOF: Nested Environment Diagrams\r#\r\rNotice how the parent for functions was always Global? Well with nested environment diagrams, you\u0026rsquo;ll finally see a situation where the parent isn\u0026rsquo;t always Global!\ndef make_adder(n): def adder(x): return x + n return adder add_3 = make_adder(3) add_3(2) \rgraph LR;\rsubgraph \"f2: adder(x) [parent = f1]\"\rf2_n[x] --- f2-5[5]\rf2_r[Return Value] --- f2-rv[5]\rend\rsubgraph \"f1: make_adder(n) [parent = Global]\"\rf1_n[n] --- 3\rf1_adder[adder] -- f1_adder_f[\"func adder(x) [parent = f1]\"]\rf1_r[Return Value] --- f1_adder_f\rend\rsubgraph Global Frame\rg_make_adder[make_adder] -- g_made_adder_f[\"func make_adder(n) [parent = Global]\"]\rg_add_3[add_3] -- f1_adder_f\rend\rAfter the code has finished executing, we can see that the environment diagram. There are some points to take note of.\nVariable Finding Procedure\r#\r\rThis was briefly mentioned in an earlier post, but the order is as follows:\n Find name in local frame If that could not be found, search one parent up and see if they have the name in that frame. Repeat until there are no more parent frames. If nothing could be found, throw an error  Why is this important?\ndef make_adder(n): def adder(x): return x + n # Important on this line return adder As you can see, the variable n is not located within the actual code body of adder, meaning that the program would not be able to execute the function if it were only allowed to search from its local frame. adder\u0026rsquo;s parent is make_adder (and its parent frame is Global), meaning that when adder is run as a function, it can search for a specific variable in its own frame, its parent frame after that (make_adder), and the parent of its parent (Global)\nHere\u0026rsquo;s a good exercise to test your understanding (Taken from lecture 5 of Fall 2021):\ndef thingy(x, y): return bobber(y) def bobber(a): return a + y result = thingy(\u0026#34;ma\u0026#34;, \u0026#34;jig\u0026#34;) What would be returned here?\nSpoiler: It\u0026rsquo;s an error. Why? Let\u0026rsquo;s make an environment diagram.\ngraph LR;\rsubgraph Global Frame\rg_thingy[thingy] -- g_thingy_f[\"func thingy(x, y) [parent = Global]\"]\rg_bobber[bobber] -- g_bobber_f[\"func bobber(a) [parent = Global]\"]\rend\rsubgraph \"f1: thingy(x, y) [parent = Global]\"\rf1_x[x] --- f1_ma[\"ma\"]\rf1_y[y] --- f1_jig[\"jig\"]\rend\rsubgraph \"f2: bobber(a) [parent = Global]\"\rf2_a[a] --- f2[\"jig\"]\rend\rNotice how f2 only has the variable a that it can access in its environment, and the variable y cannot be found within its own environment, nor can it be found in any parent after that (which in this case would just be Global Frame). As a result, this throws an error because a name could not be found.\nSelf-Referencing Functions\r#\r\rA higher order function could return a function that references its own name. Take this for example:\ndef print_sums(n): print(n) def next_sum(k): return print_sums(n + k) return next_sum print_sums(1)(3) This is quite complicated to read but understanding it is well worth the cost.\nAs you can see above, the next_sum function with parent print_sums returns print_sums itself, meaning that it\u0026rsquo;s a function that references itself, hence being self-referential.\nLet\u0026rsquo;s try to make an environment diagram for that:\ngraph LR;\rsubgraph Global Frame\rg_print_sums[print_sums] -- g_print_sums_f[\"func print_sums(n) [parent = Global]\"]\rend\rsubgraph \"f1: print_sums(n) [parent = Global]\"\rf1_n[n] --- 1\rf1_next_sum[next_sum] -- f1_next_sum_f[\"func next_sum(k) [parent = f1]\"]\rf1_r[Return Value] -- f1_next_sum_f\rend\rAfter f1 has been evaluated, we can see that the return value of f1 returns a function. Now looking at the print_sums(1)(3) statement, we can see that print_sums(1) evaluated to a function, meaning that you now have something equivalent to next_sum(3), and the value of n in that function can be found by looking at its parent frame.\ngraph LR;\rsubgraph Global Frame\rg_print_sums[print_sums] -- g_print_sums_f[\"func print_sums(n) [parent = Global]\"]\rend\rsubgraph \"f1: print_sums(n) [parent = Global]\"\rf1_n[n] --- 1\rf1_next_sum[next_sum] -- f1_next_sum_f[\"func next_sum(k) [parent = f1]\"]\rf1_r[Return Value] -- f1_next_sum_f\rend\rsubgraph \"f2: next_sum(k) [parent = f1]\"\rf2_n[k] --- 3\rend\rAt that point, the function print_sums is called again, leading to this:\ngraph LR;\rsubgraph Global Frame\rg_print_sums[print_sums] -- g_print_sums_f[\"func print_sums(n) [parent = Global]\"]\rend\rsubgraph \"f1: print_sums(n) [parent = Global]\"\rf1_n[n] --- 1\rf1_next_sum[next_sum] -- f1_next_sum_f[\"func next_sum(k) [parent = f1]\"]\rf1_r[Return Value] -- f1_next_sum_f\rend\rsubgraph \".\"\rsubgraph \"f3: print_sums(n) [parent = Global]\"\rf3_n[n] --- 4\rf3_next_sum[next_sum] -- f3_next_sum_f[\"func next_sum(k) [parent = f3]\"]\rf3_r[Return Value] -- f3_next_sum_f\rend\rsubgraph \"f2: next_sum(k) [parent = f1]\"\rf2_n[k] --- 3\rf2_r[Return Value] -- \"(Only after f3 finishes evaluating)\" -- f3_next_sum_f\rend\rend\rAs there are print statements in the function, there will also be something output to the console, which in this case is the following:\n1 4 Confusing? Sure, but it\u0026rsquo;s important to be able to draw these environment diagrams to help visualize certain parts of code.\nIt\u0026rsquo;s important to note that if another call were to be made after this function call, the parent of the next frame would be f3 as there is updated information in the outer function.\nCurrying\r#\r\rCurrying takes a single function that takes multiple arguments and turns it into a higher-order function with single arguments.\nLet\u0026rsquo;s take a look at the differences between the following functions:\nfrom operator import add add(2, 3) # two arguments def make_adder(n): return lambda x: n + x make_adder(2)(3) # higher order function with one argument in each Above, make_adder is an example of currying add(2, 3).\nA way to curry a function with any two arguments can be done like this:\ndef curryer(f): def g(x): def h(y): return f(x, y) return h return g What this does allows only a single argument to be passed into the function each time (similarly to make_adder), but because of the rules of name lookup in Python, the variables x, y, and f can still be accessible from the innermost function. You can try inputting it into PyTutor, but for this one, it\u0026rsquo;s a good exercise to try and draw it yourself before checking the answers.\n"}]