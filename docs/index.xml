<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Welcome on CS61A-Notes</title>
    <link>https://cs61a.rouxl.es/</link>
    <description>Recent content in Welcome on CS61A-Notes</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language><atom:link href="https://cs61a.rouxl.es/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Containers</title>
      <link>https://cs61a.rouxl.es/docs/week-5/content/containers/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cs61a.rouxl.es/docs/week-5/content/containers/</guid>
      <description>Containers#Lists#A list is a container that can hold a sequence of information (usually related information).
Lists can hold any Python values (not the same behaviour in every language), including other lists/objects etc.
empty = [] # empty list B = [&amp;#34;Ben&amp;#34;, &amp;#34;Box&amp;#34;, &amp;#34;&amp;#34;, &amp;#34;Bufy&amp;#34;] # Strings numbers = [2, 5, 7] # Integers floats = [2.0, 3.5, 7.5] # Floats nested = [[2, 3], 3, 4] # Storing a list inside a list mixed = [&amp;#34;Hi&amp;#34;, 2, 3.</description>
    </item>
    
    <item>
      <title>Control</title>
      <link>https://cs61a.rouxl.es/docs/week-2/content/control/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cs61a.rouxl.es/docs/week-2/content/control/</guid>
      <description>Control# Side Effects#Side effects occur in functions when the function alters the global environment in some form. This could be in the form of altering a variable in the global scope, or using a print statement inside a function. One easy way to tell if a function contains side effects is that if a function acts like a mathematical function, it has no side effects.</description>
    </item>
    
    <item>
      <title>Design</title>
      <link>https://cs61a.rouxl.es/docs/week-3/content/design/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cs61a.rouxl.es/docs/week-3/content/design/</guid>
      <description>Design#Abstraction#Abstraction (in a CS context) is broadly understood as extracting relevant information from other sources in order to simplify the codebase.
Abstraction by Parameterization#This is pretty much DRY (Don&amp;rsquo;t Repeat Yourself). Instead of hard-coding code that have similar structure, you could write a function that takes in parameters (arguments) which can be used to do the same thing. (Taken from CS61A Fall 2021 Design Slides)</description>
    </item>
    
    <item>
      <title>Introduction to the Basics of Python</title>
      <link>https://cs61a.rouxl.es/docs/week-1/content/introduction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cs61a.rouxl.es/docs/week-1/content/introduction/</guid>
      <description>The first week of CS61A is pretty simple - get used to your coding environment and a few of the basics of Python.
Lab 0#While this is optional, it&amp;rsquo;s probably best to do it just to get used to the very basics of Python as well as ok.py, the autograder used in CS61A.
You can (and should!) visualize how Python programs works with PyTutor or execute programs with code.</description>
    </item>
    
    <item>
      <title>Recursion</title>
      <link>https://cs61a.rouxl.es/docs/week-4/content/recursion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cs61a.rouxl.es/docs/week-4/content/recursion/</guid>
      <description>Recursion#Recursive Functions#A function is recursive if the body of the function calls itself (either directly or indirectly).
Recursive functions pretty much always lead to a base case by operating on increasingly smaller instances of the problem. A base case is the simplest case possible where a calculation can actually be done.
For example, a recursive function to sum the digits in a number can be written as below:</description>
    </item>
    
    <item>
      <title>Tree Recursion</title>
      <link>https://cs61a.rouxl.es/docs/week-4/content/tree-recursion/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cs61a.rouxl.es/docs/week-4/content/tree-recursion/</guid>
      <description>Tree Recursion#Order of Recursive Calls#If you know the behaviour of environment diagrams, you could derive the behaviour of recursive calls.
Recaling how environment diagrams behave, a new frame is opened when a user-defined function call occurs, meaning that whenever a recursive function is called on a non-base case scenario, a new frame is opened, and that frame will be evaluated.
As a result, in a tree recursive return value (more on that later), for example recursive(3) + recursive(4), the whole value of recursive(3) is evaluated first before recursive(4) is evaluated (due to the order of operations of Python).</description>
    </item>
    
    <item>
      <title>Decorators</title>
      <link>https://cs61a.rouxl.es/docs/week-3/content/decorators/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cs61a.rouxl.es/docs/week-3/content/decorators/</guid>
      <description>Decorators#Python decorators allow you to wrap functions inside one another easily. These may not be seen that often in the CS61A course, but in general, are pretty good to know due to the simplicity that it has as well as the common usage of it in web frameworks such as Flask, or in larger codebases.
Example Usage#Let&amp;rsquo;s take this trace function for example:
It returns a function that takes a single argument which traces the inputs and outputs of each function.</description>
    </item>
    
    <item>
      <title>Higher Order Functions</title>
      <link>https://cs61a.rouxl.es/docs/week-2/content/higher-order-functions/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cs61a.rouxl.es/docs/week-2/content/higher-order-functions/</guid>
      <description>Higher Order Functions#Designing Functions#Describing Functions#   Aspect Example     The domain of a function is the expected range of inputs (similarly to a domain in mathematics) x is a string.   The range of a function is the set of output values that could be returned Function square returns a non-negative number.   The behavior of a (pure) function is the relationship between the input and the output Function square returns the square of an input x.</description>
    </item>
    
    <item>
      <title>Sequences</title>
      <link>https://cs61a.rouxl.es/docs/week-5/content/sequences/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cs61a.rouxl.es/docs/week-5/content/sequences/</guid>
      <description>Sequences#Lists in Environment Diagrams#Lists can represented with box and pointer notation (similarly to functions); however, unlike functions, each element in the array has its own box, and is index labelled.
What this implies is that assigning a variable to another list will not create a copy of that list, but rather point towards the same list — this ends up being a correct assumption to make.</description>
    </item>
    
    <item>
      <title>Data Abstraction &#43; Dictionaries</title>
      <link>https://cs61a.rouxl.es/docs/week-5/content/data-abstraction/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cs61a.rouxl.es/docs/week-5/content/data-abstraction/</guid>
      <description>Data Abstraction#Many values in programs are compound values — a value composed of multiple values (for example coordinates, dates, or geographic positions)
By using a data abstraction, you can manipulate compound values as units without needing to worry about the way that values are stored.
Pair Abstraction#For data that is stored in pairs, we can manipulate these values using a pair data abstraction:
couple = pair(&amp;#34;a&amp;#34;, &amp;#34;b&amp;#34;) a = first(couple) b = second(couple) By implementing pair() (our constructor), first(), and second() (the selectors), you can access these elements without needing to worry about how the data is stored.</description>
    </item>
    
    <item>
      <title>Environment Diagrams</title>
      <link>https://cs61a.rouxl.es/docs/week-2/content/environment/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://cs61a.rouxl.es/docs/week-2/content/environment/</guid>
      <description>Environment Diagrams#Environment Diagrams are a good way to visualize how Python deals with its execution, and can also help you to visualize how more complicated pieces of code (e.g. Higher Order Functions) work.
PyTutor has a way of converting from code to environment diagrams, so please use that as a resource! The diagrams below are not going to match those from PyTutor exactly due to Markdown constraints, but I will try to emulate them as well as possible.</description>
    </item>
    
  </channel>
</rss>
