[{"id":0,"href":"/docs/week-5/content/containers/","title":"Containers","section":"Week 5","content":"Containers\r#\r\rLists\r#\r\rA list is a container that can hold a sequence of information (usually related information).\nLists can hold any Python values (not the same behaviour in every language), including other lists/objects etc.\nempty = [] # empty list B = [\u0026#34;Ben\u0026#34;, \u0026#34;Box\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;Bufy\u0026#34;] # Strings numbers = [2, 5, 7] # Integers floats = [2.0, 3.5, 7.5] # Floats nested = [[2, 3], 3, 4] # Storing a list inside a list mixed = [\u0026#34;Hi\u0026#34;, 2, 3.2] # Different data types inside a list List Length\r#\r\rThe globally defined len() function in Python allows you to find the length of an array, and can be called by simply passing in the array as an argument.\nlst = [2, 3, 4, 5] \u0026gt;\u0026gt;\u0026gt; len(lst) 4 This could be useful if you wanted to count the number of elements in an array to calculate the average for instance.\nWhile you could store the length of the list in a variable, it\u0026rsquo;s usually not a good idea because once the list is updated, the variable storing the length will not be updated. As a result, it\u0026rsquo;s not a bad idea to always call len() when you need to find the length unless you have a specific use for storing an outdated list length.\nlength_of_list = len(lst) # 4 lst = lst + [6] # [2, 3, 4, 5, 6], more on list concatenation later \u0026gt;\u0026gt;\u0026gt; len(lst) 5 \u0026gt;\u0026gt;\u0026gt; length_of_list 4 Indexing (Accessing List Elements)\r#\r\rNow that we have a list, well, cool! But how do we access individual elements?\nWe can use indexing for that. Each element in the list has its own index (indexes start on 0), and can be accessed by putting the index of the element in question in a square bracket.\nlst = [2, 3, 4, 5] # Index: # 0 1 2 3 \u0026gt;\u0026gt;\u0026gt; lst[0] 2 \u0026gt;\u0026gt;\u0026gt; lst[3] 5 to_get = 2 \u0026gt;\u0026gt;\u0026gt; lst[to_get] 4 \u0026gt;\u0026gt;\u0026gt; lst[4] # Will throw an error In Python, negative indices are also possible. Calling a negative index on a list will return the elements starting from the back.\n\u0026gt;\u0026gt;\u0026gt; lst[-1] 5 \u0026gt;\u0026gt;\u0026gt; lst[-2] 4 \u0026gt;\u0026gt;\u0026gt; lst[-5] # Will throw an error Notice how the first element from the back is -1 rather than 0? A somewhat easy way to imagine why that\u0026rsquo;s the case is to imagine negative indices being shorthand for len(lst) - \u0026lt;index\u0026gt; — so for example, lst[-1] would be len(lst) — equal to 4 — then minus 1, which would give 3, so it\u0026rsquo;s effectively the same thing as calling lst[3].\nList Concatenation\r#\r\rYou can add two lists together by using the + operator, or the add function, meaning that you can change the information stored in a list.\nFor now, you will only be able to add to a list with this operator (the - operator does not work on lists), but in the next page, you will see a method of how to take a subset of a list, which essentially does the same thing as removing elements in a slightly safer manner.\nlist1 = [1, 2, 3, 4] list2 = [5] \u0026gt;\u0026gt;\u0026gt; list1 + list2 [1, 2, 3, 4, 5] \u0026gt;\u0026gt;\u0026gt; add(list1, [6]) [1, 2, 3, 4, 6] .append/.push\nFor those used to other languages, you may see .append and .push used, but those actually change the values of the array, which can easily be circumvented by just adding two lists together and assigning that to a new variable. That way you have access to old versions of your variables, making your code slightly easier to read/debug.\n\rList Repetition\r#\r\rYou can also use the * operator and the mul function with lists — however you can only multiply (vanilla Python) lists with an integer, which would repeat the elements already in the list. For example:\nlst = [1, 2, 3] lst3 = lst * 3 \u0026gt;\u0026gt;\u0026gt; lst3 [1, 2, 3, 1, 2, 3, 1, 2, 3] Nested Lists\r#\r\rAs briefly mentioned earlier, you can also put lists inside of lists in Python. For example:\nlst = [[1, 2], [3, 4, \u0026#34;Hi\u0026#34;], []] If you think about this in the larger picture, lst itself only has 3 elements — 3 separate lists (with the contents inside them being irrelevant until they need to be accessed). However, once you access one of the lists, you then get another list returned (similarly to how higher-order functions worked when they returned other functions), which can then be indexed again to get a specific value.\n\u0026gt;\u0026gt;\u0026gt; lst[0] [1, 2] \u0026gt;\u0026gt;\u0026gt; lst[0][1] 2 So, knowing that information, what is the length of lst and the length of lst[2]?\nAnswer\r\u0026gt;\u0026gt;\u0026gt; len(lst) # Is somewhat equivalent to doing len([[], [], []]), or maybe len([\u0026#34;\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;]) - just different ways to view it here 3 \u0026gt;\u0026gt;\u0026gt; len(lst[1]) # Refers to the length of [] 0 \r\r\rContainment\r#\r\rYou can use the in operator to see whether a value is in a container. This operator, like ==, \u0026lt;, \u0026gt;, etc. returns a Boolean value in this context.\nlst = [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; 1 in lst True \u0026gt;\u0026gt;\u0026gt; 2 in lst True \u0026gt;\u0026gt;\u0026gt; \u0026#34;2\u0026#34; in lst False \u0026gt;\u0026gt;\u0026gt; not (3 in lst) False \u0026gt;\u0026gt;\u0026gt; 12 in lst False \u0026gt;\u0026gt;\u0026gt; [1] in lst False # This one is false because none of the elements in lst are lists themselves in (boolean operator) (checks if something is inside container (or string))\nFor Statements\r#\r\rYou can check the Control page to see the fundamental information on for loops and the range() function.\nFor lists, the range() function does not always need to be used.\nFor-in Loops\r#\r\rIf you loop through a list, you can iterate through it without using range():\nlst = [1, 2, 3] for elem in lst: # In every iteration, it binds a value from `lst` to `elem` print(elem) # Console output: # 1 # 2 # 3 If you need to access deeper than 1 level, you can use a nested for-in loop.\nSequence Unpacking Example\r#\r\rlst = [[1, 2], [3, 4]] for a, b in lst: print(a + b) # Console output: # 3 # 7 Each name is bound to a value in this case (just like in multiple assignment)\nList Comprehensions\r#\r\rList comprehension in Python is a very elegant way to create a new list by mapping an existing list\u0026rsquo;s values to a new list.\nFor example, if you wanted to add 1 to every integer in a list, you could use list comprehension in the following manner:\nlst = [1, 2, 3, 4, 5] lst_plus_1 = [x + 1 for x in lst] # [2, 3, 4, 5, 6] And if you wanted to have a list that only contained odd numbers + 1, you could do the following:\nodd_lst_plus_1 = [x + 1 for x in lst if x % 2 == 0] # [2, 4, 6] The if statement acts as a filter — it only puts elements in the new array if it passes a condition.\nWe can generalize this structure to the following:\n[\u0026lt;map expression\u0026gt; for \u0026lt;name\u0026gt; in \u0026lt;iterator\u0026gt; if \u0026lt;condition\u0026gt;] The execution procedure for this (in an environment diagram) would be to:\n Add a new frame with its current frame as its parent Create an empty result list For each element in iterator, bind it to name  If condition returns a true value, then add the value of map expression to the result list in step 2.    Strings vs Lists\r#\r\rStrings and lists have very similar behaviour (although naturally they do have some differences). They both can act as an iterator (so they can be used as an iterator in a for loop.\nSimilarities:\nstring = \u0026#34;ben\u0026#34; len(string) # 3 string[2] # n string + \u0026#34; baron\u0026#34; # ben baron However, they differ in these aspects:\nlst = [1] string = \u0026#34;B\u0026#34; string[0] == string # True lst[0] == lst # False (This is because lst[0] is equivalent to 1 as opposed to [1]) Additionally, the in operator will match substrings inside a string, but will not do so for a list.\nlst = [\u0026#34;bent\u0026#34;, \u0026#34;tao\u0026#34;] string = \u0026#34;bent\u0026#34; \u0026#34;ben\u0026#34; in lst # False \u0026#34;ben\u0026#34; in string # True "},{"id":1,"href":"/docs/week-2/content/control/","title":"Control","section":"Week 2","content":"Control\r#\r\r Side Effects\r#\r\rSide effects occur in functions when the function alters the global environment in some form. This could be in the form of altering a variable in the global scope, or using a print statement inside a function. One easy way to tell if a function contains side effects is that if a function acts like a mathematical function, it has no side effects.\nA Mathematical function f(x) takes inputs and always provides the same outputs, without doing anything else. As a result, one input will never have two or more different outputs. If a programming function has the same property where certain outputs always provide the same inputs without doing anything else, it has no side effects\nHere are a few examples:\nExample With No Side Effects\r#\r\rdef no_side_effects(x): # Squares x return x*x no_side_effects(2) # \u0026gt;\u0026gt;\u0026gt; 4 no_side_effects(2) # \u0026gt;\u0026gt;\u0026gt; 4 In this example, every input will always map to the same output as the function does not do anything other than provide an output given an input\nExample With Side Effects\r#\r\rben = 1 def with_side_effects(x): global ben # Python usually doesn\u0026#39;t like changing global variables so this statement is needed here ben += 1 # Does the same thing as ben = ben + 1 return x*ben with_side_effects(2) # \u0026gt;\u0026gt;\u0026gt; 4 with_side_effects(2) # \u0026gt;\u0026gt;\u0026gt; 6 While this example is not going to be used in a practical setting, it serves as a good example of what a side effect is. As you can see, even though we called the function with_side_effects twice with the same input, the output was different, which goes against the definition of a mathematical function. As a result, there is a side effect in that function.\n A side note:\nWhile the print function does not change the value of any variables, it does cause a side effect by outputting something to the console, which does go against how a mathematical function works. However, while side effects are usually better to avoid where possible, print could sometimes be useful for debugging.\nAn example of a side effect that can\u0026rsquo;t be avoided is writing to a file - this is necessary at times.\n A function without side effects is also known as a pure function, while a function with side effects is also known as an impure function.\nThe \u0026lsquo;None\u0026rsquo; Value\r#\r\rIn Python, any function that does not return a value will return None, which when printed will render None to the console, and when called, will not render anything in the console.\nFor example:\ndef no_return(x): x = 1 print(no_return(2)) # \u0026gt;\u0026gt;\u0026gt; None Note that the print() function has no return value, and thus will return None when called.\nNested Print Statements\r#\r\rA nested print function is somewhat weird, but worth it to learn.\nTake this for example, what do you think will get outputted to the console? Try to think for yourself before opening the answer box below.\nprint(print(1)) Answer\r# \u0026gt;\u0026gt;\u0026gt; 1 # \u0026gt;\u0026gt;\u0026gt; None This occurs because print(1) is executed first (due to the order of operations with call functions), which outputs something to console but returns None, so this statement is essentially equal to\nprint(1) print(None) \r\r\rFor a harder example, try this one:\nprint(print(\u0026#34;x\u0026#34;), print(\u0026#34;y\u0026#34;)) Answer\r# \u0026gt;\u0026gt;\u0026gt; x # \u0026gt;\u0026gt;\u0026gt; y # \u0026gt;\u0026gt;\u0026gt; None None This occurs because the call function executes the operands from left to right, so print(\u0026quot;x\u0026quot;) is called, then print(y), and because both these values return None, the outside print function will print None, None.\nIt executes the same as the sequence below:\nprint(\u0026#34;x\u0026#34;) print(\u0026#34;y\u0026#34;) print(None, None) \r\r\r Default Arguments\r#\r\rIn the function signature, one of the inputs can have a default value. This is useful in situations where there is a most likely case for a function, but where it still makes sense for users to have some control.\nFor example, the default round() function in Python takes in 1 required parameter, with 1 optional parameter (which defaults to 0).\nround(2.5342) # \u0026gt;\u0026gt;\u0026gt; 3 round(2.5342, 2) # \u0026gt;\u0026gt;\u0026gt; 2.53 You can build your own function with default arguments by simply specifying it in the header.\nFor example:\ndef ben(baron, box=\u0026#34;tao\u0026#34;): return baron + box ben(\u0026#34;baron\u0026#34;) # \u0026gt;\u0026gt;\u0026gt; \u0026#39;barontao\u0026#39; ben(\u0026#34;baron\u0026#34;, \u0026#34;hej\u0026#34;) # \u0026gt;\u0026gt;\u0026gt; \u0026#39;baronhej\u0026#39; Without the second optional parameter hej, the function defaulted to the value tao.\nIf you have multiple default arguments, you can also override them in this way:\ndef ben(baron, box=\u0026#34;tao\u0026#34;, foo=\u0026#34;baz\u0026#34;): return baron + box + foo ben(\u0026#34;baron\u0026#34;, foo=\u0026#34;yu\u0026#34;) # \u0026gt;\u0026gt;\u0026gt; barontaoyu ben(\u0026#34;baron\u0026#34;, box=\u0026#34;yu\u0026#34;) # \u0026gt;\u0026gt;\u0026gt; baronyubaz  Multiple Return Values\r#\r\rOne aspect of Python uncommon in other languages is the allowed use of multiple return values in functions. This can be done in a function by using multiple return values separated by a comma.\nAny code that calls the function can either store it in a variable as a tuple (more on this later) or can be unpacked. For example:\ndef return_two_values(): return 1, 2 return_two_values() # \u0026gt;\u0026gt;\u0026gt; (1, 2) in tuple form a, b = return_two_values() a # \u0026gt;\u0026gt;\u0026gt; 1 b # \u0026gt;\u0026gt;\u0026gt; 2 Multiple Variable Assignment\r#\r\rThe values on the right side are evaluated first before being assigned, so you can swap the values of two variables in one line by simply doing the following:\nx, y = y, x  Boolean\r#\r\rA Boolean is a value that is either True or False, and is used frequently in many applications. For example, your mobile device would likely have a Boolean variable that stores whether your WiFi, flashlight, bluetooth etc. is turned on.\nAn expression can evaluate to a Boolean. For example:\npassed_class = grade \u0026gt;= 70 # Will evaluate either true or false depending on the condition take_shower = (not eecs_major) or did_sports Comparison Operators\r#\r\r   Operator Meaning     == Equality   != Inequality   \u0026gt; Greater Than   \u0026lt; Less Than   \u0026gt;= Greater Than or Equals   \u0026lt;= Less Than or Equals    Checking for Equality It is a common mistake to use = instead of == to check for equality. Please remember that = is for assigning a variable and cannot be used for checking for equality in a conditional statement. Python will throw a syntax error, but other languages may not, so not mixing these up is a good habit to get used to.\r\rLogical Operators\r#\r\r   Operator Meaning     and Evaluates to True if both values are True   or Evaluates to True if any of the values are True   not Evaluates to True if the value is False, else evaluates to True    Execution rules of logical operators\r#\r\rThe statements are evaluated from left to right, but sometimes, these statements do not all need to be evaluated.\nand statement procedure:\n Evaluate the left statement. If it evaluates to a False value x, the expression evaluates to x. Else, the expression evaluates to the value of the expression on the right.  or statement procedure:\n Evaluate the left statement. If it evaluates to a True value x the expression evaluates to x. Else, the expression evaluates to the value of the expression on the right.  This procedure functions using just Booleans, but strange things occur when you use other values instead.\nFor example:\n5 and 2 # \u0026gt;\u0026gt;\u0026gt; 2 5 or 2 # \u0026gt;\u0026gt;\u0026gt; 5 not 5 # \u0026gt;\u0026gt;\u0026gt; False not 0 # \u0026gt;\u0026gt;\u0026gt; True 0 and False # \u0026gt;\u0026gt;\u0026gt; 0 For the and and or operators, numbers were returned rather than Booleans due to the procedure of evaluating these logical statements.\nThere is an order of operations for Booleans (not → and → or), but generally, use brackets to make your statements clearer.\nYou can use these expressions in functions as the return value. For example:\ndef boolean_example(): return is_ben or is_tao # This will return either True or False depending on the Boolean expression.  Statements\r#\r\rA statement is executed to perform an action\nCompound Statements\r#\r\rA compound statement is a statement that contains groups of other statements.\nOne example of which are conditional statements, which give your code a way to execute a different suite of statements based on whether conditions are met\nif \u0026lt;condition\u0026gt;: this_may_be_executed(1) elif \u0026lt;condition_2\u0026gt;: this_may_be_executed(2) else: this_may_be_executed(3) An if statement looks like the code above. The block indented after the if, elif, and else statements only get executed if the code directs it to.\nFor instance, if \u0026lt;condition\u0026gt; were True, then this_may_be_executed(1) is the only statement that gets evaluated, and the ones in the other blocks are skipped over.\nIf \u0026lt;condition_2\u0026gt; were True, then this_may_be_executed(2) is the only statement that gets evaluated.\nIf both \u0026lt;condition\u0026gt; and \u0026lt;condition_2\u0026gt; are False, then this_may_be_executed(3) is evaluated.\nThis means that the code does not get executed unless certain conditions are met, which is different from call expressions where every operand gets evaluated. (This property is important for some questions)\nAdditionally, this also allows for multiple return statements in functions because only that specific block gets executed, rather than every block.\ndef returning_conditional(x): if x \u0026gt; 0: return \u0026#34;positive\u0026#34; if x \u0026lt; 0: return \u0026#34;negative\u0026#34; if x == 0: return \u0026#34;neutral\u0026#34;  While Loop\r#\r\rA while loop in Python executes a block of code as long as a condition is true. This loop keeps on getting checked after each iteration.\nOne problem of a while loop is that an infinite loop can easily occur if you aren\u0026rsquo;t careful.\ncounter = 1 while counter \u0026lt; 5: print(counter) counter += 1 \u0026#39;\u0026#39;\u0026#39; \u0026gt; 1 \u0026gt; 2 \u0026gt; 3 \u0026gt; 4 \u0026#39;\u0026#39;\u0026#39; In the example above, 5 does not get printed because during that iteration, the counter variable is already 5, and the conditional 5 \u0026lt; 5 returns False.\nA while loop is very useful if you do not know how many repeats of the code you need to do, while a for loop (explained on another page) is better if you know how many loops to do.\nBreak Statement\r#\r\rIf you ever want to prematurely leave a code block, you can use the break keyword.\nwhile True: print(1) break # \u0026gt;\u0026gt;\u0026gt; 1 The above code would usually give an infinite loop, but the break statement prevents that from happening.\n For Loop\r#\r\rA for loop in Python executes a block of code for a set number of times. It provides a cleaner way to write while loops as long as they are iterating over some sort of sequence, for instance, the range() function.\nThe for loop syntax is as follows:\nfor \u0026lt;name\u0026gt; in \u0026lt;expression\u0026gt;: \u0026lt;suite\u0026gt;  Evaluate \u0026lt;expression\u0026gt; — this must evaluate to an iterable value (strings, lists (more on this later), range()) etc For each element in that \u0026lt;expression\u0026gt; (in order), bind \u0026lt;name\u0026gt; to the element in the current frame  Execute the suite, with \u0026lt;name\u0026gt; bound to a new value.    That might be slightly confusing for now, but just know that you can do everything a for loop can do with a while loop. So, if you see an example that uses a for loop, you can re-imagine it as a while loop, and it would still act the same.\nThe range() function\r#\r\rThe range() function is used quite often in conjunction with the for loop. It represents a sequence of integers. There are 3 arguments that range() takes, each of which will be explained, then demonstrated below:\n If there is just one argument x, range(x) will start on 0, then keep increasing the number by 1 until x - 1 (0 \u0026lt;= i \u0026lt; x where i is the current value) If there are two arguments x, y, range(x, y) will start on x, then keep increasing the number by 1 until y - 1. If there are three arguments x, y, z, range(x, y, z) will start on x, then keep incrementing the number by z (this can be negative), and then end on y - z.  for n in range(5): # equivalent to range(0, 5) print(n) \u0026#39;\u0026#39;\u0026#39; \u0026gt; 0 \u0026gt; 1 \u0026gt; 2 \u0026gt; 3 \u0026gt; 4 \u0026#39;\u0026#39;\u0026#39; for n in range(1, 5): print(n) \u0026#39;\u0026#39;\u0026#39; \u0026gt; 1 \u0026gt; 2 \u0026gt; 3 \u0026gt; 4 \u0026#39;\u0026#39;\u0026#39; for n in range(5, 0, -1): print(n) \u0026#39;\u0026#39;\u0026#39; \u0026gt; 5 \u0026gt; 4 \u0026gt; 3 \u0026gt; 2 \u0026gt; 1 \u0026#39;\u0026#39;\u0026#39; As can be seen in the 3 examples above, the range() function works well with the for loop.\nWhen range() is passed only 1 parameter in a for loop, it starts off at 0, then ends off at the integer before n. With 2 parameters, the for loop\u0026rsquo;s value starts off at the first parameter\u0026rsquo;s value, then ends off at the integer before the second parameter\u0026rsquo;s value. The last parameter specifies the amount n should be changed by each loop, whether it be negative or a value other than 1.\n"},{"id":2,"href":"/docs/week-3/content/design/","title":"Design","section":"Week 3","content":"Design\r#\r\rAbstraction\r#\r\rAbstraction (in a CS context) is broadly understood as extracting relevant information from other sources in order to simplify the codebase.\nAbstraction by Parameterization\r#\r\rThis is pretty much DRY (Don\u0026rsquo;t Repeat Yourself). Instead of hard-coding code that have similar structure, you could write a function that takes in parameters (arguments) which can be used to do the same thing. (Taken from CS61A Fall 2021 Design Slides)\ninterest = 1 + 0.6 * 2 interest2 = 1 + 0.9 * 4 interest3 = 1 + 2.1 * 3 As you can see above, there is a bunch of redundant code, which could be condensed into the function below (and then subsequently called with its respective arguments)\ndef interest(rate, years): return 1 + rate * years In this example, the removed detail, or the abstracted detail are the values themselves.\nAbstraction by Specification\r#\r\rInstead of building your own round function, you could just use Python\u0026rsquo;s built-in implementation, has its own specification for the inputs that it takes in (a number and the number of digits to round to), and then outputs a number based on that.\nAs a result, you could use this implementation of the round function in your code to save from implementing the code yourself.\nUsing an Abstraction\r#\r\rSay we have a specification for square(n) that takes an input n and returns the square of n. If we had this implemented already, we could use this function in our code. As a result, the code block below would run without any problems due to this abstraction.\ndef sum_squares(x, y): return square(x) + square(y) Implementing the Abstraction\r#\r\rThere are many valid ways to implement this function, but some pieces of code are less efficient or have certain effects that you may not intend for it to have.\nFor example, take a look at the possible implementations of square:\ndef square(n): return n**2 square = lambda n: n*n square = lambda n: (n*(n-1)) + n Notice how the bottom implementation takes more computational resources than the 2 implementations above? This will be more important as the pieces of code written get more complicated — the size of the program and the time efficiency can be effected by poor implementations.\nReasonable Names\r#\r\rChoosing Names\r#\r\rWhile the computer does not care about names, it greatly improves readability for humans — even yourself when you look back at the code at a later date.\nNames should convey the meaning or purpose of the values/functions bound to them. Function names specifically usually have names that convey their effect, their behaviour, or the value returned.\nParameter Names for Functions\r#\r\rFunctions take in parameter names — these too can either convey meaning, or be needlessly confusing for human readers.\nThese parameters could also be explained in the docstring, typically placed directly below the function signature.\ndef summing_function(n, func): \u0026#34;\u0026#34;\u0026#34;Sums the result of applying the function func n times from 1 to N. n: int func(n: int): function -\u0026gt; int summing_function -\u0026gt; int \u0026#34;\u0026#34;\u0026#34; total = 0 for i in range(1, n + 1): total += func(i) return total Redundant Code\r#\r\rNames should also be used if a compound expression has been repeated. For example:\nif a == b and b \u0026gt; c: print(a == b and b \u0026gt; c) You can instead store a == b and b \u0026gt; c in a variable, then use that variable for the expressions later. (I understand that the code above is very useless, but it does demonstrate a point)\nresult = a == b and b \u0026gt; c if result: print(result) More Naming Tips\r#\r\rTypically, names with one character are not very helpful in real codes: names should be more descriptive than that. However, there are exceptions:\n n, k, i: Usually used to denote an integer x, y, z: Usually real numbers/coordinates/number inputs for functions f, g, h: Shorthand for function names  Names should be long if they help self-document your code!\nDebugging + Errors\r#\r\rTypes of Errors\r#\r\rThere are different errors in Python, the most common being the following:\n Logic Error Syntax Error Runtime Error  Logic Error\r#\r\rA program has a logic error if the program does not behave as expected. This will not necessarily output something in the console, but can sometimes be discovered as a failing test or a bug report from users. This is why it\u0026rsquo;s important to write doctests for the outputs you expect — you can be sure that the code does not have logic errors.\nOne (very common) example of a logic error is the off-by-one error, where you were off by one in your implementation of a while/for loop.\nSyntax Error\r#\r\rEach programming language has its own syntactic rules. If the rules aren\u0026rsquo;t followed, the program will not necessarily be able to parse the code, thus resulting in code that cannot be executed at all. To fix these syntax errors, use the Python error log in the console to see the traceback message and see which lines they occurred at.\nRuntime Errors\r#\r\rA very common example of a runtime error is the ZeroDivisionError. These errors will happen while a program is running, and in the case of Python, it stops the execution of the program completely.\nTracebacks\r#\r\rWhen reading a Python traceback (which occurs when an error occurs), make sure to look from the bottom to the top. That way, you can see the error that occurred, and the most recent calls before the error happened.\n"},{"id":3,"href":"/docs/week-9/content/efficiency/","title":"Efficiency","section":"Week 9","content":"Efficiency\r#\r\r"},{"id":4,"href":"/docs/week-8/content/inheritance/","title":"Inheritance","section":"Week 8","content":"Inheritance\r#\r\rInheritance is a powerful tool that is very often used to reduce redundant code. If you have more specific versions of a larger class, inheritance can be extremely useful. Using our Animal class from the Objects notes, we can use all its general attributes, but then add more specific classes.\nclass Animal: default_food = [] def __init__(self, name, energy = 100): self.name = name self.food = self.default_food[:] self.energy = energy self.times_fed = 0 def feed(self, food): self.food = self.food + [food] self.times_fed += 1 self.energy += 10 def play(self): if energy \u0026lt;= 20: return \u0026#34;Not Enough Energy\u0026#34; self.energy -= 20 self.is_happy = True # Creates new instance variable return f\u0026#34;{self.name}has {self.energy}energy.\u0026#34; my_cat = Animal(\u0026#34;Sochi\u0026#34;) my_cat.feed(\u0026#34;Tuna\u0026#34;) Instead of making my_cat an instance of the Animal class, we could instead create a Cat class that inherits from the Animal class - meaning that it contains the same class, methods, and instance variables as the Animal class (which can then be overridden).\nThe syntax for creating a class inherited from another class is shown below:\nclass Cat(Animal): pass Right now, this will create a new Cat class pointing towards the Animal class we\u0026rsquo;ve already created, meaning that it can also access the class attributes/variables alongside the methods of the Animal class.\nIn the image above, we can see the Cat class we created pointing towards the Animal class, meaning that in terms of our lookup order, we first look to see if something exists in the instance, then Cat, then Animal.\nFor example, let\u0026rsquo;s edit our Cat class a bit, so it has a use, then create an instance:\nclass Cat(Animal): default_food = [\u0026#34;Tuna\u0026#34;] sochi = Cat(\u0026#34;Sochi\u0026#34;) When sochi = Cat(\u0026quot;Sochi\u0026quot;) is called, it first looks for an __init__ method in its own class (Cat), which doesn\u0026rsquo;t exist, so it looks up to its parent (Animal) for an __init__, which is found, so that __init__ method is used. If there is no __init__ method in the lookup, that method will simply not be called.\nAs a result of that, we get the following diagram (in this case, the __init__ method is called from class Animal as that is the highest level where an __init__ is defined.):\nWhen looking for self.default_food[:], default_food from the Cat class is taken, because the created instance first looks to see if there is a default_food already located in the instance (it doesn\u0026rsquo;t), then looks to where the arrow is pointing, which is the Cat class, then looks for default_food, which is then found.\r\r Our current version of the Cat class doesn\u0026rsquo;t really do much. We can override our default methods by simply redefining them in our new class. The lookup order will make it such that only our newly defined method will be called.\nclass Cat(Animal): default_food = [\u0026#34;Tuna\u0026#34;] def feed(self, food): self.food = self.food + [food] self.times_fed += 1 self.energy += 10000 Now our current diagram looks like this. If we call sochi.feed(\u0026quot;apple\u0026quot;), it will look at the feed method defined in Cat and then call it because it exists in that class.\nThe super() Function\r#\r\rThe super() function, at least in the scope of CS 61A, looks at its parent class.\nThis could be useful if you wanted to use a method of the parent class but add a few extra details. The super() function automatically passes in self.\nclass Cat(Animal): default_food = [\u0026#34;Tuna\u0026#34;] def __init__(self, name, energy = 100): super().__init__(name, energy) # will automatically define instance variables from the Animal class self.is_very_cute = True def feed(self, food): self.food = self.food + [food] self.times_fed += 1 self.energy += 10000 Now, looking at our diagrams, we have the following:\nIf we then create an instance of our newly created Cat class, we will do the following:\nFirst, create our instance and find whether an __init__ exists\nThen, if it does exist, we execute it.\nUse Cases\r#\r\rExplicit examples will not be given here because they should not be necessary. You can imagine the world of possibilities that you can do with classes and inheritance! Try thinking of how you would make a card game using OOP. Doing that will reduce A LOT of redundant code and make writing this card game easy. In fact, you might see this sort of thing show up in lab questions (alongside the Ants project).\n"},{"id":5,"href":"/docs/week-1/content/introduction/","title":"Introduction to the Basics of Python","section":"Week 1","content":"The first week of CS61A is pretty simple - get used to your coding environment and a few of the basics of Python.\nLab 0\r#\r\rWhile this is optional, it\u0026rsquo;s probably best to do it just to get used to the very basics of Python as well as ok.py, the autograder used in CS61A.\nYou can (and should!) visualize how Python programs works with PyTutor or execute programs with code.cs61a.org, but it\u0026rsquo;s probably better to use something like VSCode instead.\nAlternatively, if you have a bit of experience with other coding languages, you could look at learn X in Y\u0026rsquo;s page which will quickly get you up to speed with the syntax of Python.\n Basics of Python\r#\r\rExpressions + Values\r#\r\r Programs work to manipulate values Expressions in programs evaluate to values Values can have different data types (string, float, boolean, integer, etc.)  Python evaluates these expressions, and then (potentially) displays its values\nData Types\r#\r\r   Data Type Example Values     Integers 2, 44, 25   Floats 3.14, 2.73, 69.69   Booleans True, False   Strings Hi, ben    Operators\r#\r\rThese are pretty self-explanatory\n   Operator Example Expression What it does     + 10 + 2 Adds two values together   - 10 - 2 Subtracts values   * 10*2 Multiplies values   / 10/2 Divides values   // 9//2 Takes the floor of the divided value (result on the left would evaluate to 4)   % 9%2 Takes the remainder of the expression (result on the left would evaluate to 1)   ** 2**2 Finds the value of the left value to the power of the right value    Call Expressions\r#\r\rOftentimes, however, expressions use function calls rather than operators (and the operators above have call function equivalents!)\nFor example, running add(10, 2) does the same thing as 10 + 2 as shown in the example above, but with different form.\nSo the question is: Why use call functions?\nOne possible reason is that call functions are sometimes a lot easier to understand, especially when you have multiple nested call functions (as opposed to multiple mathematical operators)\nA call function always executes the same way with the same procedure, which goes as follows:\nadd(10, 69) add is the operator, 10 and 69 are the operands in this instance.\nPython will first evaluate the operator (and), then will evaluate the operands (10, then 69), then apply the operator (function) to the operands (arguments), in that order, which can be summarized as follows:\n Evaluate the operator  Usually this means check to see if it exists, but the operator itself may be a function in some situations.   Evaluate the operand(s) Apply the operator to the operand(s)  Operators and more commonly, operands can also be written as expressions, so these must be evaluated before step 3 can occur (meaning that if you have any sort of errors in that code block, Python will throw an error!)\nExample of nested expressions\r#\r\rfrom operator import add add(add(3,add(3,2)),add(add(5,4),add(7,6))) While the above example above is very impractical and will not appear in any sort of serious coding, it is a pretty good example of how Python evaluates nested expressions.\nLet\u0026rsquo;s unpack how Python deals with the above expression!\n Python reads from left to right in this expression, so first the add operator will be evaluated Next, the leftmost argument for add will be read, which in this case is the large block add(3,add(3,2)) As this is still another call function, the add will be evaluated, with the operands 3 and add(3,2) 3 is a \u0026lsquo;base case\u0026rsquo;, so that does not need to be further evaluated, but add(3,2) goes through the same procedure, which will then evaluate to 5. Now because the inner add function has been fully evaluated, the value is calculated in reverse order  3 + 5 is calculated, which will return 8 for the first argument.   Same thing happens for the other operand, which will then evaluate to 22 22 and 8 get summed, which will then result in 30  A visual representation (in the form of an expression tree) of what was said above can be seen below.\n Names\r#\r\rA name can be bound to a value. This does not necessarily need to be a variable - it could also be a function or an expression for instance.\nNames are often used because they can be reused in different parts of the code. A name that\u0026rsquo;s bound to a value is known as a variable.\nFor example:\nx = 2 y = 3 print(x + y) # Returns 5 print(x - y) # Returns -1 These values can also change:\nx = 2 print(x) # \u0026gt;\u0026gt;\u0026gt; 2 x = x + 5 print(x) # \u0026gt;\u0026gt;\u0026gt; 7 The equals sign used above is not similar to the one used in mathematics; it is used for assignment rather than equality, which means that you set a value to the variable.\nThis assignment statement works by\n Evaluating the expression on the right of the = Binding the value of the expression to the name on the left side of the =  Environment Diagrams\r#\r\rThese are very useful to visualize how the Python interpreter thinks (and also appear somewhat often in exam questions). PyTutor is a very good resource to generate these environment diagrams if you ever get confused about how assignment works.\nFunctions\r#\r\rFunctions are very useful in programming languages in general because they allow lines of code to be easily reused. Functions, however, are slightly more complicated than variables due to the local and global frames (more on that later).\nWhat is a function?\r#\r\rA function is a sequence of code that can be called on at any point in the program.\nWhile there are built in functions (like the add(a, b) function used earlier), sometimes, they need to be built by hand.\nA function has two portions: an input (the arguments a and b) and an output (a return value). These are not required, but depending on the use case of the function, they are very useful.\nHow do we write a function?\r#\r\rThere are two common methods to write a function in Python, with the most common one being the def statement, which can be written in the format below:\ndef \u0026lt;name\u0026gt;(\u0026lt;parameters\u0026gt;): return \u0026lt;expression\u0026gt; For example, instead of using the built-in add() function from Python, we can create our own by doing the following:\ndef add(a, b): return a + b After the code is defined (e.g. below the function definition), you can then call it:\nadd(5, 6) # \u0026gt;\u0026gt;\u0026gt; 11 In CS61A, the first line is the function signature, and all lines thereafter (there can be more than 1) are considered the function body.\nThe return keyword\r#\r\rIn a Python function statement, the return keyword is vital. What it does is return a value to the place where the function was called, and then exits the function (both properties are very important to remember!)\nThe return keyword acts very differently to print, even if they are in the same function. print does not do any assignment, while return does. The example below may help illustrate my point:\ndef example(x): print(x) return x*2 value = example(3) # Running the above line will print 3 first, then assign 3*2 to value print(value) # \u0026gt;\u0026gt;\u0026gt; 6 Frames\r#\r\rThere are different frames, which you can think of as different rooms in the same house.\nThe global frame is an environment that contains all the variables and functions that were created in the main body of the program.\nA function\u0026rsquo;s local frame is a child of the global frame, where it has its own set of variables that can\u0026rsquo;t be accessed outside the function. For example:\nunhelpful_name = 0 # variable in the global frame def unhelpful_function(unhelpful_name): # variable in the local frame (even though it has the same name it isn\u0026#39;t the same variable) return unhelpful_name # \u0026gt;\u0026gt;\u0026gt; 2 # The above will return 2 as opposed to 0 because the unhelpful_name variable called in the function is the one passed into the function. unhelpful_function(2) Name Lookup Rules\r#\r\rPython looks up names in a user-defined function using the following logic:\n Look it up in the local frame If the name is not in the local frame, look for the name in the parent frame If the name is not in any searched frame, throw a NameError.   Ending Notes\r#\r\rIf you don\u0026rsquo;t understand any of this, it is very important to ask for more help, whether that be from your peers or from your TAs, or even searching on the internet. Another very useful resource (especially for understanding how frames work) is PyTutor. Please use it.\n"},{"id":6,"href":"/docs/week-7/content/iterators/","title":"Iterators","section":"Week 7","content":"Iterators\r#\r\rWhat is an Iterator\r#\r\rAn iterator is an object that provides sequential access to values in an iterable one by one.\nWhile you may not see the use of them at the moment, the benefits of using them will be explained a bit later in these sets of notes.\n iter(iterable) returns an iterator over the elements of iterable. next(\u0026lt;iter\u0026gt;) returns the next element in an iterator.  numbers = [1, 2, 3] iter_numbers = iter(numbers) next(iter_numbers) # 1 next(iter_numbers) # 2 next(iter_numbers) # 3 next(iter_numbers) # Error (StopIterator exception) In CS61A, questions will never get to the point where handling the StopIterator error will need to happen, but a try ... except code block can handle that error. If you ever get a StopIterator error in your HW or Lab questions, you can just assume you did something wrong.\n You can think of an iterator like a bookmark and a book.\nImagine we have a list lst that contains chapters of a book, with every element containing a single chapter:\nlst = [1, 2, 3, 4, 5, 6] When we call iter on said list, we essentially create a bookmark starting on chapter 0 (before any other chapters). After finishing a chapter, calling next on the iterator will move the bookmark to chapter 1.\nlst = [1, 2, 3, 4, 5, 6] bookmark1 = iter(lst) # [1, 2, 3, 4, 5, 6] - no bookmark so far # ^ next(bookmark1) # 1 # [(1), 2, 3, 4, 5, 6] - bookmark on 1 # ^ If we wanted to create a new bookmark with the same book, we can just call iter again, which would keep bookmark1 the same.\nlst = [1, 2, 3, 4, 5, 6] bookmark1 = iter(lst) bookmark2 = iter(lst) next(bookmark1) # 1 next(bookmark1) # 2 # [1, (2), 3, 4, 5, 6] - bookmark on 2 # ^ next(bookmark2) # 1 # [(1), 2, 3, 4, 5, 6] - bookmark on 1 # ^ Calling an Iterator on an Iterator\r#\r\rIf you call iter on an already-made iterator, similarly to lists, it just points to the same iterator. With our bookmark analogy, it\u0026rsquo;s like getting another variable pointing to the same bookmark — calling next on one instance will also update the bookmark for the other variable.\nlst = [1, 2, 3, 4, 5, 6] bookmark1 = iter(lst) alt_bookmark1 = iter(bookmark1) next(bookmark1) # 1 next(alt_bookmark1) # 2 Calling Iterators on Iterables\r#\r\rstrings, lists, dictionaries, tuples, ranges, etc. are all iterables. You can call iterators on them and access them sequentially. This should be pretty obvious, but there are special methods that exists for dictionaries\nDictionaries\r#\r\rnumbers = { \u0026#34;one\u0026#34;: 1, \u0026#34;two\u0026#34;: 2, \u0026#34;three\u0026#34;: 3 } # Iterator for keys key_iter = iter(numbers.keys()) next(key_iter) # \u0026#34;one\u0026#34; # Iterator for values value_iter = iter(numbers.values()) next(value_iter) # 1 # Iterators for key/value tuples dict_iter = iter(numbers.items()) next(dict_iter) # (\u0026#34;one\u0026#34;, 1) Iterators with For Loops\r#\r\rWhen an iterator is used in a for ... in loop, Python will keep calling next on the iterator until a StopIterator error occurs.\nlst = [1, 2, 3] iter_lst = iter(lst) for item in iter_list: print(item) # 1 # 2 # 3 next(iter_lst) # StopIterator error The for loop would go through the whole book, moving the bookmark to the end. As a result, when you call next again, the bookmark would be at the end, meaning that there are no more additional chapters, so a StopIterator error will occur.\nThis behaviour implies that iterators are mutable. One an iterator moves forward, it is unable to return the values that came before.\r\rUseful Built-in Functions\r#\r\rFunctions that return iterables\r#\r\r   Function Description     list(iterator) Returns a list of all items in iterator starting on the current pointer location.   tuple(iterator) Returns a tuple of all items in iterator starting on the current pointer location.   sorted(iterator) Returns a sorted list of all items in iterator starting on the current pointer location.    Functions that return iterators\r#\r\rThese are slightly more complicated, so examples will be given for each of the following below:\nreversed(sequence): Iterates over item in sequence in reverse order. Returns an iterator.\nlst = [1, 2, 3] print(list(reversed(lst))) # [3, 2, 1] # list() needs to be called because reversed returns an iterator for item in reversed(lst): print(item) # 3 # 2 # 1 zip(*iterables): Iterates over co-indexed tuples with elements from each iterable. Stops at the shortest list.\nlst1 = [1, 2, 3] lst2 = [4, 5, 6] for t in zip(lst1, lst2): print(t) # (1, 4) # (2, 5) # (3, 6) for x, y in zip(lst1, lst2) print(x + y) # 5 # 7 # 9 Map and Filter\r#\r\rFor map and filter specifically, you can simply use list comprehensions — they\u0026rsquo;re shorter and far more \u0026lsquo;Pythonic\u0026rsquo;. However, knowing the notation for these two functions can help you recognize them in other languages.\nmap(function, iterable):\nlst = [1, 2, 3] mapped_lst = map(lambda x: x*2, lst) print(list(mapped_lst)) # [2, 4, 6] # Which is the same thing as [x*2 for x in lst] filter(function, iterable):\nlst = [1, 2, 3] mapped_lst = map(lambda x: x % 2 == 1, lst) print(list(mapped_lst)) # [1, 3] # Which is the same thing as [x for x in lst if x % 2 == 1] "},{"id":7,"href":"/docs/week-4/content/recursion/","title":"Recursion","section":"Week 4","content":"Recursion\r#\r\rRecursive Functions\r#\r\rA function is recursive if the body of the function calls itself (either directly or indirectly).\nRecursive functions pretty much always lead to a base case by operating on increasingly smaller instances of the problem. A base case is the simplest case possible where a calculation can actually be done.\nFor example, a recursive function to sum the digits in a number can be written as below:\ndef sum_digits(n): assert n \u0026gt;= 0 if n \u0026lt; 10: # Base case, only happens when there\u0026#39;s 1 remaining digit return n return sum_digits(n // 10) + n % 10 # Adds the rest of the number with the final number # sum_digits(n // 10) just calls the sum_digits function again but with a simpler case in this case. Another example is a factorial function:\ndef factorial(n): assert n \u0026gt;= 0 if n == 1 or n == 0: return 1 else: n * factorial(n - 1) If you notice how factorial works, it repeatedly multiplies n with a value one lower than itself, which allows the recursive function above to work.\nAs a result, the anatomy of a recursive function can be broken down into the following components:\n Base Case: The smallest sub-problem Recursive Case: Breaking down a problem into a smaller sub-problem Conditional Statement: Decides whether something is a base case or a recursive case.  Recursion in Environment Diagrams\r#\r\rIf we use the same factorial function from above, calling factorial(3) on it, we can visualize the function calls in the environment diagram below in two steps — first reaching the base case, then evaluating the result.\n\rmermaid.initialize({\r\"flowchart\": {\r\"useMaxWidth\":true\r},\r\"theme\": \"dark\"\r}\r)\rgraph LR;\rsubgraph \"f3: factorial(x) [parent = Global]\"\rf3-n[n] --- f3-1[1]\rf3-rv[Return Value] --- f3-r[1]\rend\rsubgraph \"f2: factorial(x) [parent = Global]\"\rf2-n[n] --- f2-3[2]\rf2-rv[Return Value] --- f2-r[\"2 * (factorial(1))\"]\rend\rsubgraph \"f1: factorial(x) [parent = Global]\"\rf1-n[n] --- f1-3[3]\rf1-rv[Return Value] --- f1-r[\"3 * (factorial(2))\"]\rend\rsubgraph Global Frame\rfactorial -- factorial_fucntion[\"func factorial(n) [parent = Global]\"]\rend\rAfter the base case is reached, each return value in the stack can be evaluated:\ngraph LR;\rsubgraph \"f3: factorial(x) [parent = Global]\"\rf3-n[n] --- f3-1[1]\rf3-rv[Return Value] --- f3-r[1]\rend\rsubgraph \"f2: factorial(x) [parent = Global]\"\rf2-n[n] --- f2-3[2]\rf2-rv[Return Value] --- f2-r[\"2 * 1 = 2\"]\rend\rsubgraph \"f1: factorial(x) [parent = Global]\"\rf1-n[n] --- f1-3[3]\rf1-rv[Return Value] --- f1-r[\"3 * 2 = 6\"]\rend\rsubgraph Global Frame\rfactorial -- factorial_fucntion[\"func factorial(n) [parent = Global]\"]\rend\rAs a result, we can visualize a recursive call almost like that of a stack. The values keep reducing to a simpler case until a base case is reached, and when that happens, the result for each recursive call (starting from the base case) is then evaluated, which then will combine to evaluate to the final result.\nVerifying Recursive Functions\r#\r\rDomino Example\r#\r\rLet\u0026rsquo;s use an example to illustrate how designing/verifying a recursive function can work.\nTake for example that you had a line of a thousand equally spaced dominoes, and you wanted to test whether tipping one would tip all of them, you could just see if 1 domino would fall if tipped, then assume that any domino will tip the next one, then verify that tipping the first domino tips the next one.\nThis can be generalized with two different methods:\nRecursive Leap of Faith\r#\r\rSteps:\n Verify the base case — make sure it\u0026rsquo;s functional and works properly Assume that a simplified case of the function is correct (← leap of faith) Verify that the function itself returns the simplified function calls correctly  For a more concrete example, take the factorial function from above:\n Verify that return 1 if n == 0 or n == 1 is the correct base case Assume that factorial(n - 1) returns the correct value Verify that n * factorial(n - 1) is the correct statement  Recursive Cat\u0026rsquo;s Promise\r#\r\rWhile this usually isn\u0026rsquo;t a cat\u0026rsquo;s promise, but rather an elf, I like cats, so I\u0026rsquo;m going to go with cats.\nWith this perspective, the recursive cat handles the simplified recursive call, and promises that they will calculate the smaller recursive call for you while you handle the rest.\nFor example, to calculate 3!, you would ask yourself how you could calculate 3! if you knew the value of 2!, which in this case, is simply 3 * 2! — as a result, you do! Then, the recursive cat promises to handle the result of factorial(2) for you. (The recursive cat then calls on itself to find the value of factorial(1), but you do not need to know that to be able to solve factorial(5) — all you need is the value of factorial(4))\nMutual Recursion\r#\r\rWhen recursive functions are defined in terms of each other, the functions are mutually recursive.\nFor example, we can have this (useless) function that determines whether a number is even or odd in a mutually recursive manner:\ndef even(n): if n == 0: return True else: return odd(n - 1) def odd(n): if n == 0: return False else: return even(n - 1) print(even(4)) # True Note:\nMutually recursive functions can be written as a single recursive function by simply breaking the abstraction boundary between the two functions. For example, the code above can be written in the following manner:\ndef even(n): if n == 0: return True else: if (n - 1) == 0: return False return even((n - 1) - 1) As you can see, the code checks whether a number is even initially, then checks for the odd case and thus, deals with 2 digits in 1 go. However, this implementation is far more convoluted than the mutually recursive version (and you can imagine how much more complex this would be with more complexity), so using a mutually recursive solution can simply be a mechanism for keeping your code simple; in other words: maintaining abstraction.\n\rA good indicator of when a mutual recursive solution could be used is when there is a natural recursive solution, but there is more than 1 case that needs to be checked for (in the above example, whether the number was even or odd)\nRecursion + Iteration\r#\r\rConverting Recursion to Iteration\r#\r\rFirst, you must figure out what state needs to be maintained by the iterative function that the recursive function would store itself. For example, in the factorial function, the recursive function works by multiplying n with a simpler version of the factorial function, meaning that the iterative version would need something to store n and multiply it with n - 1 until a \u0026lsquo;base case\u0026rsquo; is reached.\nFor instance:\ndef recursive_factorial(n): assert n \u0026gt;= 0 if n == 1 or n == 0: return 1 else: return n * recursive_factorial(n - 1) def iterative_factorial(n): k = n - 1 while k \u0026gt; 0: # \u0026#39;Base Case\u0026#39; n = n * k # Does the multiplication k = k - 1 # Decrements n, similar to recursive_factorial(n - 1) return k Converting Iteration to Recursion\r#\r\rConverting iteration to recursion is sometimes easier than doing it the other way around. Essentially, the state of an iteration can be passed in as arguments to the recursive function:\ndef iterative_sum_digits(n): total = 0 while n \u0026gt;= 10: digit_sum = digit_sum + n % 10 #  n = n // 10 return total def recursive_sum_digits(n, total): if n \u0026lt; 10: return n else: return(n // 10, total + n % 10) # Iterative variables passed as arguments for the recursive version Helper Functions\r#\r\rIf a recursive function ever needs to keep track of more variables than the original function provides, you probably need a helper function for that.\ndef is_prime(n): \u0026#39;\u0026#39;\u0026#39;Returns True if n is a prime number, else returns False \u0026gt;\u0026gt;\u0026gt; is_prime(13) True \u0026gt;\u0026gt;\u0026gt; is_prime(14) False \u0026gt;\u0026gt;\u0026gt; is_prime(2) True \u0026#39;\u0026#39;\u0026#39; assert n \u0026gt;= 2 def helper(i): if i == n: return True elif n % i == 0: return False else: return helper(i + 1) return helper(2) "},{"id":8,"href":"/docs/week-4/content/tree-recursion/","title":"Tree Recursion","section":"Week 4","content":"Tree Recursion\r#\r\rOrder of Recursive Calls\r#\r\rIf you know the behaviour of environment diagrams, you could derive the behaviour of recursive calls.\nRecaling how environment diagrams behave, a new frame is opened when a user-defined function call occurs, meaning that whenever a recursive function is called on a non-base case scenario, a new frame is opened, and that frame will be evaluated.\nAs a result, in a tree recursive return value (more on that later), for example recursive(3) + recursive(4), the whole value of recursive(3) is evaluated first before recursive(4) is evaluated (due to the order of operations of Python).\nTree Recursion\r#\r\rTree recursion occurs when a recursive function makes more than one recursive call, thus creating a sort of network of sorts of recursive calls that is sort of shaped like the roots of a tree.\nFibonacci Numbers\r#\r\rdef fib(n): if n \u0026lt;= 0: return 0 elif n == 1: return 1 return fib(n - 1) + fib (n - 2) fib(3) As you can see in the example above, the recursive call returns two instances of the same function, thus creating a structure that calls itself multiple times in a sort of tree-like fashion (as seen in the image below)\nNotice how this is pretty inefficient though! There are multiple calls to fib(1), so that function would need to be evaluated multiple times (and this redundant execution would get executed more if we started with fib(4) for instance). There are ways to alleviate this (to a certain extent), but\nCounting Partitions\r#\r\rThe solution to this classic tree recursion problem has a structure that can be used in other tree recursive problems — it\u0026rsquo;s worth truly understanding how it works.\nThe question is defined as follows:\nCount the number of possible partitions with positive integers n, using parts up to size m.\nThis problem has two distinct parts, one part calculating the possibilities with the current size m, and the other part calculating the possibilities with smaller part sizes m - 1 in a recursive manner.\nFor example, for count_partitions(4, 3), you could have the following outcomes:\n3 1\r2 2\r2 1 1\r1 1 1 1\rWhich would return 4 as those are the total number of possibilities. Each line break represents a different path for the recursive solution.\nIn general, the recursive call can be generalized as follows count_partitions(n - m, m) + count_partitions(n, m - 1) which essentially is adding up the recursive function for the case where m is used, and the case where m is not used. After we have this logic, we just need to come up with the base cases, and assume that our recursive solution will work.\nFor our base cases, we know that if n is ever negative, there will be no possible results, and if m is equal to 0, it will not be possible to create any partitions of size n (other than 0). For n = 0, you can create 1 total partition by using partition size 0 (which is still less than m).\nAs a result, the code can be written as follows:\ndef count_partitions(n, m): if n == 0: return 1 elif n \u0026lt; 0 or m == 0: return 0 return count_partitions(n - m, m) + count_partitions(n, m - 1) "},{"id":9,"href":"/docs/week-6/content/trees/","title":"Trees","section":"Week 6","content":"Trees\r#\r\rA tree is an abstract data structure (basically not implemented by default in Python), which means we need to use data abstractions in order to implement this structure.\nWhat does a tree look like?\r#\r\rA tree has a root and a list of branches, where each branch is a tree itself.\nA tree with zero branches (the white circles in the drawing above) is called a leaf. A tree also starts at the root, which in the drawing above, is the blue circle.\nWhile this may not look like a tree, but rather roots of the tree itself, you could potentially think of the drawing as an upside down tree.\r\rAlso notice how when we look at the branches stemming from the root, we have two separate sub-trees? This means that recursion will be a common way to go about solving tree-related problems.\n Each location in a tree can be called a node, and each node has a label which contains the value located within the node (can be any value). Nodes can be parents/children of each other, and the top node is the root node.\nTree Data Abstraction\r#\r\rThere are many possible data abstraction for trees, but the one that CS61A uses is the following:\n   Abstraction Description     tree(label, branches = []) Returns a tree with root label and a list of branches   label(tree) Returns the label of the tree   branches(tree) Returns the branches of the tree (in a list) — each of which is a tree by itself   is_leaf(tree) Returns True if the current node is a leaf node.    For example, a tree could be the following:\nt = tree(3, # Root Node # Branches: [tree(2, [tree(1)], # Left Branch tree(4))] # Right Branch ) The actual implementation of the tree is information that you do not need to know in order to use this data structure, so I will not write the implementation here. The documentation for these data abstractions says that branches(tree) returns a list, meaning that calling branches(tree)[0] is not a violation of data abstraction here.\nTree Processing\r#\r\rAs mentioned earlier, tree problems are solved recursively. Let\u0026rsquo;s figure out why:\nEach tree has the following:\n A label 0 or more branches, with each branch containing a tree itself.  Due to the fact that each branch contains a tree itself, this data type is recursive.\nExample Questions\r#\r\rCounting Leaves\r#\r\rIf we wanted to count the number of leaves in a tree, how would we do that? Obviously, the solution has to be recursive, so we need to start with the recursive mindset:\n What is our base case? What is our recursive case?  def count_leaves(t): \u0026#39;\u0026#39;\u0026#39;Returns the number of leaf nodes in tree t\u0026#39;\u0026#39;\u0026#39; if is_leaf(t): return 1 else: total_leaves = 0 for b in branches(t) total_leaves += count_leaves(b) return total_leaves In the code above, our base case happens when we hit a leaf, and the recursive call uses a for loop to go through all the branches in our tree, and then add the number of leaves to total_leaves, which is then returned.\nWe could also use the sum() function alongside a list comprehension to condense our code:\ndef count_leaves(t): \u0026#39;\u0026#39;\u0026#39;Returns the number of leaf nodes in tree t\u0026#39;\u0026#39;\u0026#39; if is_leaf(t): return 1 else: return sum([count_leaves(b) for b in branches(t)]) This works because the sum function can sum up the elements in an iterable.\nCreating Trees\r#\r\rA function that creates another tree based off of an existing tree is often recursive.\nLet\u0026rsquo;s recall how a tree is built:\nt = tree(3, # Root Node # Branches: [tree(2, [tree(1)], # Left Branch tree(4))] # Right Branch ) Let\u0026rsquo;s try and make a function that doubles each node in a tree:\ndef double(t): \u0026#39;\u0026#39;\u0026#39;Returns a tree with same structure as t, but with each node doubled\u0026#39;\u0026#39;\u0026#39; if is_leaf(t): return tree(label(t*2)) else: return tree(label(t*2), [double(b) for b in branches(t)]) Notice how we have repeated code? We can actually shorten the code to one line because of that (the base case here doesn\u0026rsquo;t need to be made explicit, will explain why later)\ndef double(t): \u0026#39;\u0026#39;\u0026#39;Returns a tree with same structure as t, but with each node doubled\u0026#39;\u0026#39;\u0026#39; return tree(label(t*2), [double(b) for b in branches(t)]) In the final code, we don\u0026rsquo;t need a base case/recursive case structure that you would traditionally see for recursive questions, but even so, it\u0026rsquo;s a good idea to think of it that way before condensing it down.\nThe code above works because in the case of a leaf node, [] gets passed into branches within the tree constructor, which by default takes in an empty list if there are no branches. Thus, in the case of a leaf node, all that gets returned there is equivalent of saying tree(label(t*2)).\nPrinting Trees\r#\r\rdef print_tree(t, indent = 0): \u0026#39;\u0026#39;\u0026#39;Prints the labels of t with depth based indent\u0026#39;\u0026#39;\u0026#39; print(\u0026#34; \u0026#34; * indent + str(label(t))) for b in branches(t): print_tree(tree(b), indent + 1) Look at the example above and see how it works. indent + 1 is important as it will indent the tree to the correct level.\n"},{"id":10,"href":"/docs/week-3/content/decorators/","title":"Decorators","section":"Week 3","content":"Decorators\r#\r\rPython decorators allow you to wrap functions inside one another easily. These may not be seen that often in the CS61A course, but in general, are pretty good to know due to the simplicity that it has as well as the common usage of it in web frameworks such as Flask, or in larger codebases.\nExample Usage\r#\r\rLet\u0026rsquo;s take this trace function for example:\nIt returns a function that takes a single argument which traces the inputs and outputs of each function.\ndef trace1(f): def traced(x): print(f\u0026#34;Input: {x}\u0026#34;) result = f(x) print(f\u0026#34;Output: {result}\u0026#34;) return result return traced If we wanted to trace abs(-4) using trace1, we would call trace1(abs)(-4) to get an output in the console of:\n\u0026#39;\u0026#39;\u0026#39; \u0026gt;\u0026gt;\u0026gt; trace1(abs)(-4) Input: -4 Output: 4 \u0026#39;\u0026#39;\u0026#39; You could also use it in the following way if you wanted the trace function to be called on every instance of a function being called:\ndef square(x): return x*x square = trace1(square) The code above would then make sure the trace1 function is wrapped around every square call, meaning that when square is called, trace1 is always used.\nHowever, there is a shorthand way of doing the above, which is to use a decorator:\n@trace1 def square(x): return x*x "},{"id":11,"href":"/docs/week-7/content/generators/","title":"Generators","section":"Week 7","content":"Generators\r#\r\rWhat is a generator?\r#\r\rGenerators can be used to create your own iterators with custom values. This is useful when you want to create an iterator with unpredictable results (for example numbers with irregular intervals, possibly based on different arguments in a given function).\nThe way you define a generator function is through the yield keyword (instead of return in a function). In this sense, a generator is a type of iterator that yields results from a generator function.\ndef numbers(): num = 0 while num \u0026lt; 3: yield num num += 1 Calling the generator function will return a generator (which itself is an iterator, which means the next function works similarly to how it does for iterators):\nnum_iter = numbers() next(num_iter) # 0 next(num_iter) # 1 next(num_iter) # 2 next(num_iter) # StopIterator How generators work\r#\r\rWhen the function called, Python immediately returns an iterator without running any lines of code in the function itself.\nWhen next is called on the iterator, it starts executing the body of the function until it hits the first yield statement. Once it hits the yield statement, the function pauses execution (not to be confused with return where the function completely stops executing), and when next is called again, the function will continue executing from where it paused. If it doesn\u0026rsquo;t find any yield statements from there, it raises a StopIteration exception.\ndef printer(n): print(\u0026#34;we have started\u0026#34;) while n \u0026lt; 3: yield n n = n + 1 printing = printer(0) next(printing) # we have started # 0 next(printing) # 1 next(printing) # 2 next(printing) # StopIteration We can use for loops over generators like we can over iterators:\ndef printer(n): print(\u0026#34;we have started\u0026#34;) while n \u0026lt; 3: yield n n = n + 1 for item in printer(0): print(item) # we have started (goes through the function body as normal) # 0 # 1 # 2 Why use generators?\r#\r\rFor some functions, using generators can save a lot of computing time. This is because they only generate the next item when needed (instead of having to find every solution in a recursive solution for example, you can just compute one element as a time (as you need it) in certain situations).\nExample: Fibonacci Numbers\r#\r\rInstead of an iterative solution\ndef fib(n): prev = 0 curr = 1 iterations = 1 while iterations \u0026lt; n: prev, curr = curr, prev + curr iterations += 1 return curr we can use a generator for this:\ndef gen_fib(): prev = 0 curr = 1 while True: yield prev prev, curr = curr, prev + curr This will allow you to generate Fibonacci numbers as needed.\nYield From\r#\r\rThe yield from keyword allows you to yield from an iterable/iterator one at a time:\ndef lst_yielder(): lst = [0, 1, 2, 3] yield from lst lst = lst_yielder() next(lst) # 0 next(lst) # 1 next(lst) # 2 next(lst) # 3 However, one of the very cool things about yield from is that you can yield the results of another generator function, which makes it act sort of like recursion in a way.\ndef countdown(n): if k \u0026gt; 0: yield n yield from countdown(n - 1) When the function hits yield from countdown(n - 1), it makes another instance of countdown, with a lower value of n, which will then pause when it reaches yield n in the function body.\nGenerator Functions with Returns\r#\r\rUsing a return keyword in a generator function does not work exactly as intended.\nRemember how earlier it was mentioned that if a function was unable to find another yield statement, it would cause a StopIteration error? Well, what a return statement does traditionally is exit out of a function, which in this case means that no further yield statement will be found. As a result, a StopIteration error will occur.\ndef f(x): yield x yield x + 1 return yield x + 2 list(f(1)) # [1, 2] With Return Values\r#\r\rdef f(x): yield x yield x + 1 return x + 1 yield x + 2 list(f(1)) # [1, 2] Notice how nothing changed? Return values can\u0026rsquo;t be yielded in this way. There is a way to yield these return values, but it is not in the scope of CS61A.\nCount Partitions (Yield)\r#\r\rdef partitions(n, m): \u0026#34;\u0026#34;\u0026#34;List partitions. \u0026gt;\u0026gt;\u0026gt; for p in partitions(6, 4): print(p) 4 + 2 4 + 1 + 1 3 + 3 3 + 2 + 1 3 + 1 + 1 + 1 2 + 2 + 2 2 + 2 + 1 + 1 2 + 1 + 1 + 1 + 1 1 + 1 + 1 + 1 + 1 + 1 \u0026#34;\u0026#34;\u0026#34; if n \u0026lt; 0 or m == 0: return else: if n == m: yield str(m) for p in partitions(n - m, m): yield f\u0026#34;{m}+ {p}\u0026#34; yield from partitions(n, m - 1) This one is a bit difficult to understand. Let\u0026rsquo;s break it down.\nThe base case n \u0026lt; 0 or m == 0 has a return statement in it. What this means is that if we ever get to the point where either of these cases happen, a StopIteration error will occur, which in this program, means that specific combination will not be yielded.\nIn the case where n == m, it means that there will only be one possible combination to make up that partition, so that specific partition size will be yielded.\nAfterwards, we use a for loop to deal with the case where we do use m (because using yield from does not allow you to change the values that you want to yield), then just yield from the case where m isn\u0026rsquo;t used and it decreases by 1.\n"},{"id":12,"href":"/docs/week-2/content/higher-order-functions/","title":"Higher Order Functions","section":"Week 2","content":"Higher Order Functions\r#\r\rDesigning Functions\r#\r\rDescribing Functions\r#\r\r   Aspect Example     The domain of a function is the expected range of inputs (similarly to a domain in mathematics) x is a string.   The range of a function is the set of output values that could be returned Function square returns a non-negative number.   The behavior of a (pure) function is the relationship between the input and the output Function square returns the square of an input x.    Don\u0026rsquo;t Repeat Yourself!\r#\r\rWhen making a function, give each function exactly one job, but allow it to be flexible to apply to many related situations. Doing this allows you to remove redundant code and make your code clearer to read, and easier to write.\nGeneralization\r#\r\rIf you see a common structure, you can refactor your code to move the redundant code to a function and call that instead.\nFor example, if we take this code block below:\ndef print_ben_if_positive(n): if n \u0026gt; 0: print(\u0026#34;ben\u0026#34;) def print_ben_if_positive(n): if n \u0026gt; 0: print(\u0026#34;tao\u0026#34;) We can see that the if statement is duplicated, so we can take that logic to another function instead, removing redundant code.\ndef positive_print(number, message): if number \u0026gt; 0: print(message) positive_print(n, \u0026#34;ben\u0026#34;) positive_print(n, \u0026#34;tao\u0026#34;) Higher-order Functions\r#\r\rA higher-order function is a function that takes another function as an argument, or returns a function as its result.\nFunctions as Arguments\r#\r\rA function can take another function as an argument.\nfrom operator import add, sub def function_in_function(adding_function, x, y): return adding_function(x, y) function_in_function(add, 3, 2) # \u0026gt;\u0026gt;\u0026gt; 5 function_in_function(sub, 3, 2) # \u0026gt;\u0026gt;\u0026gt; 1 In the example above, we passed the add and sub functions to the function function_in_function. This is an example of a higher order function.\nNote that in the call functions themselves, add and sub were called rather than add() and sub(). This is because of how call functions are evaluated. Running add() directly will make the Python interpreter try to evaluate the function itself with no parameters, which would not work, while simply typing add will allow function_in_function to evaluate add() with the proper parameters.\r\rFunctions as Return Values\r#\r\rAnother way to have a higher order function is to return a function.\nFunctions created in other functions are bound to names in their local frame, allowing for cleaner naming when creating function calls. For example:\ndef make_adder(magnitude): def adder(n): return n + magnitude return adder add_two = make_adder(2) add_three = make_adder(3) print(add_two(2), add_three(2)) # \u0026gt;\u0026gt;\u0026gt; 4 5 While the example above may not have much practical use, it shows the process of returning a function within a function, making this another higher order function. Take your time to digest how the above two examples work. This will be harder to conceptualize at the beginning.\nCall Expressions as operator expressions\r#\r\rYou can run a function like make_adder(2)(3) which will return 5. Why is that? Let\u0026rsquo;s look at how the call function order works.\n make_adder(2) is first evaluated, which returns a function adder similarly to the function above. Due to adder being returned from the operator, the final statement will end up being adder(3), leading to 5 being the final output  Lambda Expressions\r#\r\rLambda expressions pretty much work the same way as regular functions, other than the fact that these functions are anonymous - they do not have a name assigned to it.\nThe syntax looks like the following:\nlambda \u0026lt;parameters\u0026gt;: \u0026lt;expression\u0026gt; For instance:\ndouble = lambda x: y*2 double(3) # \u0026gt;\u0026gt;\u0026gt; 6 While this may not seem very useful in this context, there are quite a few uses for it. The main idea is that lambda functions are better suited for functions that you want to access in the short term, or only access once.\nA lambda function does not contain any statements at all, including if statements and return statements.\nFor instance, instead of doing\nfrom operator import add def square(x): return x**2 add(2, square(2)) You can do the following:\nfrom operator import add add(2, lambda x: x**2) Conditional Expressions\r#\r\rlambda functions not allowing statements can be quite limiting, but that is where conditional expressions come in.\nA conditional expression has a form that almost reads like English:\n\u0026lt;do this (true)\u0026gt; if \u0026lt;condition\u0026gt; else \u0026lt;do this (false)\u0026gt; This may be strange if you\u0026rsquo;re used to ternary operators in other languages (for example JavaScript) as the order of reading the Python statement may be a bit strange.\nHowever, the operation order is the following:\n Check the truthiness of \u0026lt;condition\u0026gt; If true, evaluate \u0026lt;do this (true)\u0026gt; Else, evaluate \u0026lt;do this (false)\u0026gt;  In conjunction with lambda functions, you can do the following:\nlambda x: x if x \u0026gt; 0 else 0 The code block above returns the input if it is positive, else returns 0.\n"},{"id":13,"href":"/docs/week-6/content/mutability/","title":"Mutability","section":"Week 6","content":"Mutability\r#\r\rObjects\r#\r\rAn object is a bundle of data and behaviour, with each type of object called a class\nEvery value in Python is an object.\nAll objects have attributes, and objects often have associated methods\nExample (Strings)\r#\r\rA string is an object — try running type(\u0026quot;\u0026quot;) in Python console and seeing what it outputs.\nStrings have attributes (for example the data inside it) and also has methods such as string.upper().\nList Mutation\r#\r\rLists (like dictionaries) are object types that can be mutated. This means that the value bound to the name can change without reassignment. This can potentially be very useful, but at times, can also be very dangerous due to the way Python works with lists.\nTwo methods to mutate lists:\ns = [1, 2] s.append(3) s # [1, 2, 3] l = [1, 2] l.extend([4]) l # [1, 2, 4] l.extend([3, 2]) l # [1, 2, 4, 3, 2] While these look identical to s = s + [3], they behave very differently. This is because the + operator makes a shallow copy of the list rather than directly mutating the list itself. This makes a difference when two names are pointing to the same list object.\nTry running the code below on PythonTutor:\nlst1 = [1, 2, 3] lst2 = lst1 lst3 = lst2 # Notice how after the above 3 statements are executed, all 3 names point to the same list object lst1 = lst1 + [3, 2] # Makes a copy of the list, does not mutate the original lst2.append(4) print(lst1) # [1, 2, 3, 3, 2] print(lst2, lst3) # [1, 2, 3, 4] [1, 2, 3, 4] Notice how even after I updated only lst2, lst3 got updated alongside it. This is one of the dangers of mutation (and is why I generally prefer to use a method that doesn\u0026rsquo;t mutate anything: it makes debugging a lot easier when variables aren\u0026rsquo;t changing without explicitly being assigned to change.)\nMethod Mutation (Removing)\r#\r\r pop() returns and removes the last element in the list remove() removes the first element equal to the argument  s = [1, 2] s.pop() s # [1] l = [1, 2, 4] l.remove(2) l # [1, 4] Mutation with Slicing\r#\r\rYou can also mutate lists with list slicing or indexing:\nlst = [1, 2, 3, 4, 5] lst[0] = \u0026#34;Hi\u0026#34; lst # [\u0026#34;Hi\u0026#39;, 2, 3, 4, 5] lst[1:3] = [25, 6] lst # [\u0026#34;Hi\u0026#34;, 25, 6, 4, 5] lst[1:1] = [3, 2, 1] # Inserting Elements lst # [\u0026#34;Hi\u0026#34;, 3, 2, 1, 25, 6, 4, 5] lst[:5] = [] # Deleting Elements lst # [6, 4, 5] lst[len(lst):] = [3] # Appending elements lst # [6, 4, 5, 3] All the statements above mutate the list that we have.\nPython Weirdness\r#\r\rIn Python, doing lst = lst + [1] is different to lst += [1].\n+= actually acts as .extend([...]) rather than making a copy. As a result, doing lst += [1] mutates the original list, while lst = lst + [1] does not mutate the original. Weird behaviour, sure, but this is very important to know.\nTuples\r#\r\rTuples are a data type that are immutable. This means that once the tuple is created and assigned to a name, you can be confident that the tuple will always remain the same unless the name is bound to a different value.\nTuples are also a sequence, which means you can view them as essentially immutable lists.\nempty = () # empty tuple coordinates = (32, 21) # tuple with multiple elements temperature = (30,) # tuple with 1 element (the , at the end is necessary for python to parse it as a tuple) The read-only list operators work with tuples:\nt1 = (1, 2) t2 = (3, 4) t3 = t1 + t2 t3 # (1, 2, 3, 4) 1 in t2 # False 1 in t3 # True t4 = t3[1:] # (2, 3, 4) Identity vs Equality\r#\r\rIdentity vs Equality essentially boils down to is vs ==. The is Boolean operator checks whether the objects are the same (for example in the case of a list, whether the two names are pointing to the same list), while the == operator just checks whether the values are the same.\nlst1 = [1, 2] lst2 = lst1 lst3 = [1, 2] lst1 is lst2 # True lst1 is lst3 # False lst1 == lst3 # True \u0026lsquo;Mutable\u0026rsquo; Functions (A function with changing state)\r#\r\rYou can have a function that changes state by having a mutable object in the parent frame:\ndef bank(initial_fund): bank_account = [initial_fund] def withdraw(amount): if bank_account[0] \u0026lt; amount: return \u0026#34;NO!\u0026#34; else: bank_account[0] = bank_account[0] - amount return bank_account return withdraw withdrawer = bank(100) withdrawer(25) # 75 withdrawer(25) # 50 "},{"id":14,"href":"/docs/week-8/content/representation/","title":"Representation","section":"Week 8","content":"String Interpolation\r#\r\rThis is not part of representation, but is instead an extremely useful tool to make writing strings with multiple variables far cleaner. You may have already seen me use string interpolation earlier on in the course.\nIn Python, the cleanest way to use string interpolation is with an f-string, where the letter f is appended before quotation marks.\nf\u0026#34;\u0026#34; You can see the syntax highlighting sees the f in a different colour! With this notation, we can then put expressions in our string itself and have them evaluate to \u0026lsquo;proper\u0026rsquo; values. Different languages deal with string interpolation in different manners.\none = 1 two = \u0026#34;two\u0026#34; five = \u0026#34;five\u0026#34; f\u0026#34;{one + 1}{two}, {five}\u0026#34; # will return \u0026#34;2 two, five\u0026#34; Representation\r#\r\rBuilt-in Object Attributes\r#\r\rIn Python, every built in type inherits from object. Everything in Python is an object of some sort. As a result, they all have their own dunder methods that are different for every object.\nIf you run dir() on an object (which could be a string, list, or something else), you will see a list of its methods. Behind the scenes, Python runs these dunder methods, so we don\u0026rsquo;t really need to worry about those (kind of like data abstraction if you think about it)\nString Representation\r#\r\rThe __str__ method returns a string representation made to be human readable.\nThe use of this method is most likely better with a concrete example, so let\u0026rsquo;s define our own class for Rational numbers (similarly to the data abstraction we were using earlier).\nfrom math import gcd class Rational: def __init__(self, numerator: int, denominator: int): g = gcd(numerator, denominator) self.numerator = numerator // g self.denominator = denominator // g So far, if we make an instance of the class and then print that instance, we get a non-useful output:\n\u0026gt;\u0026gt;\u0026gt; my_rational = Rational(2, 3) \u0026gt;\u0026gt;\u0026gt; print(my_rational) \u0026lt;__main__.Rational object\u0026gt; When we define our own __str__ method, calling print() on the instance will look for the __str__ method and return the value. However, the print method removes quotes, while calling str() on the same thing will not remove quotes (an example will be given in the doctests).\nclass Rational: \u0026#34;\u0026#34;\u0026#34; \u0026gt;\u0026gt;\u0026gt; my_rational = Rational(2, 3) \u0026gt;\u0026gt;\u0026gt; print(my_rational) 2 / 3 \u0026gt;\u0026gt;\u0026gt; str(my_rational) \u0026#39;2 / 3\u0026#39; \u0026#34;\u0026#34;\u0026#34; def __init__(self, numerator: int, denominator: int): g = gcd(numerator, denominator) self.numerator = numerator // g self.denominator = denominator // g def __str__(self): return f\u0026#34;{self.numerator}/ {self.denominator}\u0026#34; # We define how our class will look in the console here Machine Representation\r#\r\rOn the other hand, the __repr__ method is used to return a string that would evaluate to an object with the same values (in a traditional sense - when you override the __repr__ method, you can set it to anything you want)\nThe goal is to make it such that when you call eval() on the result, it should return the same valued object (but not the same pointer).\nclass Rational: \u0026#34;\u0026#34;\u0026#34; \u0026gt;\u0026gt;\u0026gt; my_rational = Rational(2, 3) \u0026gt;\u0026gt;\u0026gt; my_rational Rational(2, 3) \u0026gt;\u0026gt;\u0026gt; eval(Rational.__repr__(my_rational)) Rational(2, 3) \u0026gt;\u0026gt;\u0026gt; repr(my_rational) \u0026#39;Rational(2, 3)\u0026#39; \u0026#34;\u0026#34;\u0026#34; def __init__(self, numerator: int, denominator: int): g = gcd(numerator, denominator) self.numerator = numerator // g self.denominator = denominator // g def __str__(self): return f\u0026#34;{self.numerator}/ {self.denominator}\u0026#34; def __repr__(self): return f\u0026#34;Rational({self.numerator}, {self.denominator})\u0026#34; Notice how calling repr(my_rational) returned what you would expect but in quotation marks.\nImplicit calling of print()\r#\r\r   Type Methods of Calling     Implicitly calls print() Directly calling in interactive environment; print()   Does not implicitly call print() repr(), str()    Doing print(\u0026quot;Ben\u0026quot;) to the console will output Ben (without the quote marks). In other words, calling print() on something removes a set of quote marks. However, calling str(\u0026quot;Ben\u0026quot;) in the console will output 'Ben' instead, suggesting that it doesn\u0026rsquo;t call print() to remove the set of quotes. If we directly output something to the console, it first calls repr() on it, then prints it to the console. So overall, when we just call something, it does the equivalent of print(repr(\u0026quot;Ben\u0026quot;)), which is the same as print(\u0026quot;'Ben'\u0026quot;), which will remove the outside set of quotes and then return 'Ben' to the console.\nprint(\u0026#34;Ben\u0026#34;) # Ben \u0026#34;Ben\u0026#34; # \u0026#39;Ben\u0026#39; (comes from print(repr(\u0026#34;Ben\u0026#34;))) repr(\u0026#34;Ben\u0026#34;) # \u0026#34;\u0026#39;Ben\u0026#39;\u0026#34; str(\u0026#34;Ben\u0026#34;) # \u0026#39;Ben\u0026#39; Special Methods\r#\r\rThere are other special dunder methods that map to built-in behaviour. For example, the __add__ method is called when two objects are added together:\n2 + 3 # is the same as 2.__add__(3) If we wanted to add two of our Rational classes together, it would error because there is currently no __add__ method defined. However, if we were to define our own __add__ method, we could make it such that Python would know how to deal with addition!\nclass Rational: def __init__(self, numerator: int, denominator: int): g = gcd(numerator, denominator) self.numerator = numerator // g self.denominator = denominator // g def __add__(self, other): assert isinstance(other, Rational) # Will require that the other thing passed in was a rational new_numerator = self.numerator * other.denominator + other.numerator * self.denominator new_denominator = self.denominator * other.denominator return Rational(new_numerator, new_denominator) def __str__(self): return f\u0026#34;{self.numerator}/ {self.denominator}\u0026#34; def __repr__(self): return f\u0026#34;Rational({self.numerator}, {self.denominator})\u0026#34; This can be done for other methods like __mul__ - you just have to implement them yourselves.\nWeird behaviour of str and repr\r#\r\rrepr()\r#\r\r Will ignore any instance variables created called __repr__. Only looks for this instance variable in the class.  str()\r#\r\r Will ignore any instance variables created called __str__. Only looks for this instance variable in the class. If no __str__ is found (in the whole lookup order), it defaults to the first __repr__ it can find.  "},{"id":15,"href":"/docs/week-5/content/sequences/","title":"Sequences","section":"Week 5","content":"Sequences\r#\r\rLists in Environment Diagrams\r#\r\rLists can represented with box and pointer notation (similarly to functions); however, unlike functions, each element in the array has its own box, and is index labelled.\nWhat this implies is that assigning a variable to another list will not create a copy of that list, but rather point towards the same list — this ends up being a correct assumption to make.\nEach box can either hold a value (for example a number or a string), or an object (for example, a function, another list, or a Class).\nList Slicing\r#\r\rSlicing a list creates a new list (as in it points to a separate list). The behaviour is very similar to the range() function — it starts on the first \u0026lsquo;argument\u0026rsquo; provided, ends on the number right before the second \u0026lsquo;argument\u0026rsquo;, with step of the third \u0026lsquo;argument\u0026rsquo;. In this case however, the separator is : rather than ,. If there is no argument provided next to the :, it defaults to 0.\nThe syntax is lst[\u0026lt;start\u0026gt;:\u0026lt;end\u0026gt;:\u0026lt;step_size\u0026gt;]\nBelow are some examples:\nlst = [1, 2, \u0026#34;bananas\u0026#34;] lst[0:] # [1, 2, \u0026#34;bananas\u0026#34;] lst[:2] # [1, 2] lst[1:] # [2, \u0026#34;bananas\u0026#34;] lst[::2] # [1, \u0026#34;bananas\u0026#34;] This behaviour also works with strings:\nstring = \u0026#34;benbaron\u0026#34; string[3:] # \u0026#34;baron\u0026#34; string[:3] # \u0026#34;ben\u0026#34; Small Practice Problems\r#\r\rRecursion in Lists\r#\r\rImagine summing the numbers in a list but using recursion rather than iteration or the sum() function.\ndef sum_numbers(lst): \u0026#39;\u0026#39;\u0026#39;Returns the sum of the numbers in lst \u0026gt;\u0026gt;\u0026gt; sum_numbers([2, 3, 4]) 9 \u0026#39;\u0026#39;\u0026#39; We could implement the function above using list comprehension:\ndef sum_numbers(lst): \u0026#39;\u0026#39;\u0026#39;Returns the sum of the numbers in lst \u0026gt;\u0026gt;\u0026gt; sum_numbers([2, 3, 4]) 9 \u0026#39;\u0026#39;\u0026#39; if lst == []: # base case return 0 else: return lst[0] + sum_numbers(lst[1:]) # takes the first number and  # recursively calls the function on a smaller list. Reversing a String (Recursively)\r#\r\rdef reverse_string(word): \u0026#39;\u0026#39;\u0026#39;Reverse the string provided in word \u0026gt;\u0026gt;\u0026gt; reverse_string(\u0026#34;ben\u0026#34;) neb \u0026#39;\u0026#39;\u0026#39; Our base case here would be when the word provided is an empty string.\ndef reverse_string(word): \u0026#39;\u0026#39;\u0026#39;Reverse the string provided in word \u0026gt;\u0026gt;\u0026gt; reverse_string(\u0026#34;ben\u0026#34;) neb \u0026#39;\u0026#39;\u0026#39; if word == \u0026#34;\u0026#34;: return \u0026#34;\u0026#34; else: return reverse_string(word[1:]) + word[0] # keep in mind the order of the operation above matters # word[0] is put afterwards because # that should be added up later Built-in functions for Iterables\r#\r\r   Function Description     sum(iterable, start) Returns the sum of the values in iterable, with a starting sum of start (defaults to 0)   all(iterable) Returns True if all the values of iterable are Truthy values (or if the iterable is empty), else returns False   any(iterable) Returns True if any of the values of iterable are Truthy, else returns False   max(iterable, key=None) Returns the maximum value in iterable   min(iterable, key=None) Returns the minimum value in iterable    Examples of the built-in functions\r#\r\rsum([3, 2, 1], 50) # 56 any([True, False, False, False]) # True any([3, 2, 1, 0]) # True all([3, 2, 1]) # True all([True, False, False, False]) # False max([3, 2, 1]) # 3 max([\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;, \u0026#34;c\u0026#34;]) # \u0026#34;c\u0026#34; max(range(10)) # 9 # the \u0026#39;key\u0026#39; parameter can be used to compare certain elements in an array: coords = [[1, 2], [4, 3], [3, 90]] max(coords, key = lambda x: x[0]) # [4, 3] (x iterates through coords and then checks the max value of the first element) "},{"id":16,"href":"/docs/week-5/content/data-abstraction/","title":"Data Abstraction + Dictionaries","section":"Week 5","content":"Data Abstraction\r#\r\rMany values in programs are compound values — a value composed of multiple values (for example coordinates, dates, or geographic positions)\nBy using a data abstraction, you can manipulate compound values as units without needing to worry about the way that values are stored.\nPair Abstraction\r#\r\rFor data that is stored in pairs, we can manipulate these values using a pair data abstraction:\ncouple = pair(\u0026#34;a\u0026#34;, \u0026#34;b\u0026#34;) a = first(couple) b = second(couple) By implementing pair() (our constructor), first(), and second() (the selectors), you can access these elements without needing to worry about how the data is stored. The only time that people need to worry about how the data is stored is when implementing the functions themselves. One example (implying that there are multiple ways) of implementing these functions can be seen below:\ncouple = lambda a, b: [a, b] first = lambda lst: lst[0] second = lambda lst: lst[1] Rational Numbers\r#\r\rOne reasonable data abstraction to do is to implement rational numbers as a data abstraction. By storing the numerator and denominator separately, we can get precise values of certain fractions such as 1/3.\nFor example:\nhalf = rational(1, 2) top = numerator(half) # 1 bottom = denominator(half) # 2 We have the structure for a denominator\u0026hellip; cool I guess? But at its current state, we can\u0026rsquo;t do anything with the numbers in terms of multiplying/adding/printing them in the way that we expect. As a result, we can write more functions to help us do that using functions.\ndef mul_rational(x, y): return rational( numerator(x) * numerator(y), denominator(x) * denominator(y) ) def add_rational(x, y): nx, dx = numerator(x), denominator(x) ny, dy = numerator(y), denominator(y) return rational( nx * dy + ny * dx, dx * dy ) Notice how at this point we still do not know how rational() is implemented.\nImplementation\r#\r\rdef rational(n, d): return [n, d] def numerator(rational): return rational[0] def denominator(rational): return rational[1] However, rational(n, d) doesn\u0026rsquo;t fully simplify the fractions, so to solve that, we can divide both n and d by the greatest common denominator:\ndef rational(n, d): g = gcd(n, d) return [n // g, d // g] Layers of Abstraction\r#\r\rYou might be wondering, what\u0026rsquo;s the point of data abstraction?\nOne reason is that some things are a lot harder to code/understand (in terms of legibility) without using data abstraction in Python (for example coding a tree), but the main reason is for simplicity and extensibility.\nWhat data abstraction does is allow changing the implementation of the function itself without actually needing to manually change all the instances of it. In addition, with a good data abstraction, the programmer will not need to know how the data is implemented, but just needs to use the constructors and selectors to do the job for them.\nAbstraction Barriers\r#\r\r   Layer Examples     Representation/Implementation [x, y], [0], [1]   Data Abstraction 1 make_rational, numerator, denominator   Data Abstraction 2 mul_rational, add_rational   User Programs Could be anything using the layer above    Each layer would only need to use the layer above it, meaning that when users use the data abstractions, they do not need to care about how it\u0026rsquo;s implemented.\nHowever, this requires that the abstraction barriers are not violated. For example, if you were to do:\nadd_rational([1, 2], [3, 4]) You would be violating the abstraction barrier. This would not work if the implementation of rational were changed for instance. As a result, make sure to use both the constructors and the selectors instead of assuming what the implementation is.\nDictionaries\r#\r\rA dictionary is another way to store multiple pieces of data, however, it is stored differently to that of lists, and is also accessed slightly differently.\nEach element in a dictionary stores a key and a value as a pair, with each element separated by a , (similarly to lists) which looks like the following below:\nmy_fruits = {\u0026#34;apples\u0026#34;: 2, \u0026#34;bananas\u0026#34;: 25} If we had the following dictionary, we could call my_fruits[\u0026quot;apples] to get the value of apples, which in this case would return 2. If we wanted to edit the amount of apples we had, we would then assign a value to the index: myfruits[\u0026quot;apples\u0026quot;] = 3 would mutate our dictionary that we have.\nQueries\r#\r\r\u0026gt;\u0026gt;\u0026gt; \u0026#34;apples\u0026#34; in my_fruits # able to search for keys True \u0026gt;\u0026gt;\u0026gt; 2 in my_fruits # not able to search for values False \u0026gt;\u0026gt;\u0026gt; len(my_fruits) 2 Rules\r#\r\rkeys cannot be a list or a dictionary (or any mutable type). However, values can be of any types (including dictionaries).\nThere can only be one value mapped to every key (similarly to mathematical functions)\nIteration\r#\r\rfor fruit in my_fruits: print(fruit, my_fruits[fruit]) # apples 2 # bananas 25 Notice that fruit iterates through the keys and not the values!\r\rDictionary Comprehensions\r#\r\rVery similar to list comprehensions, but it uses {} instead of []; in the form of {\u0026lt;key\u0026gt;: \u0026lt;value\u0026gt; for x in \u0026lt;iter\u0026gt;}.\n{x: x*x for x in [1, 2, 3, 4]} # would return a dictionary of  { 1: 1, 2: 4, 3: 9, 4: 16 } "},{"id":17,"href":"/docs/week-2/content/environment/","title":"Environment Diagrams","section":"Week 2","content":"Environment Diagrams\r#\r\rEnvironment Diagrams are a good way to visualize how Python deals with its execution, and can also help you to visualize how more complicated pieces of code (e.g. Higher Order Functions) work.\nPyTutor has a way of converting from code to environment diagrams, so please use that as a resource! The diagrams below are not going to match those from PyTutor exactly due to Markdown constraints, but I will try to emulate them as well as possible.\nVariable Assignment\r#\r\rx = 2 y = 5 When the code block above is run, the value 2 will be assigned to the name x, and afterwards, the value 5 will be assigned to the name y, which can be seen in an environment diagram like the one below:\n\rmermaid.initialize({\r\"flowchart\": {\r\"useMaxWidth\":true\r},\r\"theme\": \"dark\"\r}\r)\rgraph LR;\rsubgraph Global Frame\rx --- 2\ry --- 5\rend\rIn each frame, there can only be one name bound to one value - it is not possible to have one name point to two different values.\nFunction Assignment\r#\r\rFunctions are notated differently to variables due to the potential need to overwrite a binding without losing the value of a function somewhere else (will make sense later).\ndef square(n): return n*n square(3) This will be executed in two different steps: creating the function, then executing the function.\ndef square(n): return n*n \rgraph LR;\rsubgraph Global Frame\rsquare -- id1[\"func square(x) [parent = Global]\"]\rend\rsquare(3) When a function is called, a new frame is created, leading to another environment for Python to execute code from. Note that an environment variable only needs the function name, parameter(s), and parent frame in the environment diagram.\ngraph LR;\rsubgraph Global Frame\rsquare -- id1[\"func square(x) [parent = Global]\"]\rend\rsubgraph \"f1: square [parent = Global]\"\rn --- 3\rid2[Return Value] --- 9\rend As can be seen in the environment diagram above, a new unique frame f1 is created, which has all the passed in parameters (in this case, just n = 3) stored. Then, when the return statement is reached, it simply evaluates the right side of the return statement (in this case n*n), then returns that value (9)\nConfusing Function Assignment Example\r#\r\r(Taken from Fall 2021 Discussion 1)\ndef double(x): return x * 2 def triple(x): return x * 3 hat = double double = triple The functions double and triple\u0026rsquo;s environment diagrams are pretty self-explanatory, but the next two statements hat = double and double = triple are slightly more confusing. Let\u0026rsquo;s break it down:\ngraph LR;\rsubgraph Global Frame\rdouble -- double_function[\"func double(x) [parent = Global]\"]\rtriple -- triple_function[\"func triple(x) [parent = Global]\"]\rend\rWhat would happen with hat? In this case, it points to the function double(x) rather than the name double itself. This means that hat becomes a copy of double rather than acting as double. Take a look at the environment diagram below:\ngraph LR;\rsubgraph Global Frame\rdouble -- double_function[\"func double(x) [parent = Global]\"]\rtriple -- triple_function[\"func triple(x) [parent = Global]\"]\rhat -- double_function\rend\rBoth double and hat point to the same function double(x)!\nNow, what would happen with double = triple? You can simply extrapolate the actions above, but quite simply, the pointers change.\ngraph LR;\rsubgraph Global Frame\rdouble -- triple_function\rtriple -- triple_function[\"func triple(x) [parent = Global]\"]\rhat -- double_function[\"func double(x) [parent = Global]\"]\rend\rThis means that you can still call the double(x) function through hat, but you can no longer call it through double. Additionally, even when double was overwritten, the function double(x) itself was not deleted!\nCall Expressions\r#\r\rThe important thing to note is that when executing call expressions, a new frame is created to keep track of local variables. The order of operations is as follows:\n Evaluate the operator - this should evaluate to a function. Evaluate the operands from left to right. Make a new frame with:  A unique index The real name of the function (not the name of the variable pointing to it) (for example, for double(n)) The parent frame   Bind values to names in this new frame. Evaluate the function in this new frame until a return value is obtained.  Example from Fall 2021 Discussion 1:\ndef double(x): return x * 2 hmmm = double wow = double(3) hmmm(wow) \rgraph LR;\rsubgraph Global Frame\rdouble -- double_function[\"func double(x) [parent = Global]\"]\rhmm -- double_function\rend\rAfter the function double(x) is bound to a name, and hmm is bound to that function, we create a new frame to evaluate wow = double(3).\nWhen evaluating that statement, the right side is evaluated before being assigned to the name on the left side. As a result, wow will not appear in the environment diagram until after the return value is created.\ngraph LR;\rsubgraph Global Frame\rdouble -- double_function[\"func double(x) [parent = Global]\"]\rhmm -- double_function\rwow -- \"(After the return value below is evaluated)\" --- outer[6]\rend\rsubgraph \"f1: double(x) [parent = Global]\"\rx --- 3\rreturn[Return Value] --- 6\rend\rAfterwards, hmmm(wow) is called, which is essentially the same thing as doing hmmm(6). As hmmm is pointing to func double(x) [parent = Global], it will run that function, passing in the parameter 6. However, because this is a new function, a new frame will be created.\ngraph LR;\rsubgraph Global Frame\rdouble -- double_function[\"func double(x) [parent = Global]\"]\rhmm -- double_function\rwow -- \"(After the return value below is evaluated)\" --- outer[6]\rend\rsubgraph \"f1: double(x) [parent = Global]\"\rx --- 3\rreturn[Return Value] --- 6\rend\rsubgraph \"f2: double(x) [parent = Global]\"\rf2-x[x] --- f2-6[6]\rf2-return[Return Value] --- f2-return-value[12]\rend\rNested Call Expression\r#\r\rEnvironment diagrams can also help visualize how to deal with nested call expressions.\nFor example:\ndef double(x): return x*2 result = double(double(2)) How would this look in an environment diagram?\nFirst, the inner double(2) gets evaluated, so a frame is created for that, then the return value from that is used in the outer function, so another frame is created for that.\ngraph LR;\rsubgraph Global Frame\rdouble -- double_function[\"func double(x) [parent = Global]\"]\rend\rsubgraph \"f1: double(x) [parent = Global]\"\rf1-x[x] --- f1-2[2]\rf1-rv[Return Value] --- f1-r[4]\rend\rAfter the inner function is evaluated, the return value is then passed into the function to be run again in another frame:\ngraph LR;\rsubgraph Global Frame\rdouble -- double_function[\"func double(x) [parent = Global]\"]\rend\rsubgraph \"f1: double(x) [parent = Global]\"\rf1-x[x] --- f1-2[2]\rf1-rv[Return Value] --- f1-r[4]\rend\rsubgraph \"f2: double(x) [parent = Global]\"\rf2-x[x] --- f2-4[4]\rf2-rv[Return Value] --- f2-r[8]\rend\rNote: Both of the parents of the function are the global frame because the function itself is called, and that is located inside the parent frame.\r\rNames in Environments\r#\r\rNames have different meanings in different environments!\ndef double(double): return double + double double(2) Please do not write code like this. It is merely a demonstration of how names and environments interact.\ngraph LR;\rsubgraph Global Frame\rglobal_double[double] -- glob_double_function[\"func double(double) [parent = Global]\"]\rend\rsubgraph \"f1: double(double) [parent = Global]\"\rf1_double[double] --- 2\rf1_r[Return Value] --- 4\rend\rNotice how the different environment frames allow for the name double to exist twice with different assignments.\nEnvironment Diagrams for Higher-order Functions\r#\r\rNote that functions are first class in Python - they act the same as values.\nHOF: Takes a function as an argument\r#\r\rdef run_twice(func, *args): return func(func(*args)) def double(x): return x*2 double_double = run_twice(double(2)) What *args does here is simply allow for a flexible number of arguments to be passed in rather than a set number - allows for more flexibility even though it doesn\u0026rsquo;t do much here.\ngraph LR;\rsubgraph Global Frame\rglobal_run_twice[run_twice] -- global_run_twice_function[\"func run_twice(func, *args) [parent = Global]\"]\rglobal_double[double] -- global_double_function[\"func double(x) [parent = Global]\"]\rend\rAfter assigning the functions to the names, we get the environment diagram seen above. To evaluate double_double = run_twice(double(2)), you have to remember the order of operations for call functions. First, evaluate the operators (make sure it exists/is not a higher order function), then evaluate the operands, then apply the operator to the operands.\nIn this context it means that run_twice is evaluated first with the proper pointers, then double is run after that is done.\ngraph LR;\rsubgraph Global Frame\rglobal_run_twice[run_twice] -- global_run_twice_function[\"func run_twice(func, *args) [parent = Global]\"]\rglobal_double[double] -- global_double_function[\"func double(x) [parent = Global]\"]\rend\rsubgraph \"f1: run_twice(func, *args) [parent = Global]\"\rf1_func[func] -- global_double_function\rf1_args[args] --- 3\rend\rsubgraph \"f2: double(x) [parent = Global]\"\rf2_x[x] --- f2_3[3]\rf2_r[Return Value] --- 6\rend\rAfterwards, we get the following:\ngraph LR;\rsubgraph Global Frame\rglobal_run_twice[run_twice] -- global_run_twice_function[\"func run_twice(func, *args) [parent = Global]\"]\rglobal_double[double] -- global_double_function[\"func double(x) [parent = Global]\"]\rglobal_double_double[double_double] --- global_12[12]\rend\rsubgraph \"f1: run_twice(func, *args) [parent = Global]\"\rf1_func[func] -- global_double_function\rf1_args[args] --- 3\rf1_r[Return Value] -- \"(Only after f3's return value is evaluated)\" --- f1_rv[12]\rend\rsubgraph \"f2: double(x) [parent = Global]\"\rf2_x[x] --- f2_3[3]\rf2_r[Return Value] --- 6\rend\rsubgraph \"f3: double(x) [parent = Global]\"\rf3_x[x] --- f3-6[6]\rf3_r[Return Value] --- f3_rv[12]\rend\rThese environment diagrams do get somewhat complicated.\nHOF: Nested Environment Diagrams\r#\r\rNotice how the parent for functions was always Global? Well with nested environment diagrams, you\u0026rsquo;ll finally see a situation where the parent isn\u0026rsquo;t always Global!\ndef make_adder(n): def adder(x): return x + n return adder add_3 = make_adder(3) add_3(2) \rgraph LR;\rsubgraph \"f2: adder(x) [parent = f1]\"\rf2_n[x] --- f2-5[5]\rf2_r[Return Value] --- f2-rv[5]\rend\rsubgraph \"f1: make_adder(n) [parent = Global]\"\rf1_n[n] --- 3\rf1_adder[adder] -- f1_adder_f[\"func adder(x) [parent = f1]\"]\rf1_r[Return Value] --- f1_adder_f\rend\rsubgraph Global Frame\rg_make_adder[make_adder] -- g_made_adder_f[\"func make_adder(n) [parent = Global]\"]\rg_add_3[add_3] -- f1_adder_f\rend\rAfter the code has finished executing, we can see that the environment diagram. There are some points to take note of.\nVariable Finding Procedure\r#\r\rThis was briefly mentioned in an earlier post, but the order is as follows:\n Find name in local frame If that could not be found, search one parent up and see if they have the name in that frame. Repeat until there are no more parent frames. If nothing could be found, throw an error  Why is this important?\ndef make_adder(n): def adder(x): return x + n # Important on this line return adder As you can see, the variable n is not located within the actual code body of adder, meaning that the program would not be able to execute the function if it were only allowed to search from its local frame. adder\u0026rsquo;s parent is make_adder (and its parent frame is Global), meaning that when adder is run as a function, it can search for a specific variable in its own frame, its parent frame after that (make_adder), and the parent of its parent (Global)\nHere\u0026rsquo;s a good exercise to test your understanding (Taken from lecture 5 of Fall 2021):\ndef thingy(x, y): return bobber(y) def bobber(a): return a + y result = thingy(\u0026#34;ma\u0026#34;, \u0026#34;jig\u0026#34;) What would be returned here?\nSpoiler: It\u0026rsquo;s an error. Why? Let\u0026rsquo;s make an environment diagram.\ngraph LR;\rsubgraph Global Frame\rg_thingy[thingy] -- g_thingy_f[\"func thingy(x, y) [parent = Global]\"]\rg_bobber[bobber] -- g_bobber_f[\"func bobber(a) [parent = Global]\"]\rend\rsubgraph \"f1: thingy(x, y) [parent = Global]\"\rf1_x[x] --- f1_ma[\"ma\"]\rf1_y[y] --- f1_jig[\"jig\"]\rend\rsubgraph \"f2: bobber(a) [parent = Global]\"\rf2_a[a] --- f2[\"jig\"]\rend\rNotice how f2 only has the variable a that it can access in its environment, and the variable y cannot be found within its own environment, nor can it be found in any parent after that (which in this case would just be Global Frame). As a result, this throws an error because a name could not be found.\nSelf-Referencing Functions\r#\r\rA higher order function could return a function that references its own name. Take this for example:\ndef print_sums(n): print(n) def next_sum(k): return print_sums(n + k) return next_sum print_sums(1)(3) This is quite complicated to read but understanding it is well worth the cost.\nAs you can see above, the next_sum function with parent print_sums returns print_sums itself, meaning that it\u0026rsquo;s a function that references itself, hence being self-referential.\nLet\u0026rsquo;s try to make an environment diagram for that:\ngraph LR;\rsubgraph Global Frame\rg_print_sums[print_sums] -- g_print_sums_f[\"func print_sums(n) [parent = Global]\"]\rend\rsubgraph \"f1: print_sums(n) [parent = Global]\"\rf1_n[n] --- 1\rf1_next_sum[next_sum] -- f1_next_sum_f[\"func next_sum(k) [parent = f1]\"]\rf1_r[Return Value] -- f1_next_sum_f\rend\rAfter f1 has been evaluated, we can see that the return value of f1 returns a function. Now looking at the print_sums(1)(3) statement, we can see that print_sums(1) evaluated to a function, meaning that you now have something equivalent to next_sum(3), and the value of n in that function can be found by looking at its parent frame.\ngraph LR;\rsubgraph Global Frame\rg_print_sums[print_sums] -- g_print_sums_f[\"func print_sums(n) [parent = Global]\"]\rend\rsubgraph \"f1: print_sums(n) [parent = Global]\"\rf1_n[n] --- 1\rf1_next_sum[next_sum] -- f1_next_sum_f[\"func next_sum(k) [parent = f1]\"]\rf1_r[Return Value] -- f1_next_sum_f\rend\rsubgraph \"f2: next_sum(k) [parent = f1]\"\rf2_n[k] --- 3\rend\rAt that point, the function print_sums is called again, leading to this:\ngraph LR;\rsubgraph Global Frame\rg_print_sums[print_sums] -- g_print_sums_f[\"func print_sums(n) [parent = Global]\"]\rend\rsubgraph \"f1: print_sums(n) [parent = Global]\"\rf1_n[n] --- 1\rf1_next_sum[next_sum] -- f1_next_sum_f[\"func next_sum(k) [parent = f1]\"]\rf1_r[Return Value] -- f1_next_sum_f\rend\rsubgraph \".\"\rsubgraph \"f3: print_sums(n) [parent = Global]\"\rf3_n[n] --- 4\rf3_next_sum[next_sum] -- f3_next_sum_f[\"func next_sum(k) [parent = f3]\"]\rf3_r[Return Value] -- f3_next_sum_f\rend\rsubgraph \"f2: next_sum(k) [parent = f1]\"\rf2_n[k] --- 3\rf2_r[Return Value] -- \"(Only after f3 finishes evaluating)\" -- f3_next_sum_f\rend\rend\rAs there are print statements in the function, there will also be something output to the console, which in this case is the following:\n1 4 Confusing? Sure, but it\u0026rsquo;s important to be able to draw these environment diagrams to help visualize certain parts of code.\nIt\u0026rsquo;s important to note that if another call were to be made after this function call, the parent of the next frame would be f3 as there is updated information in the outer function.\nCurrying\r#\r\rCurrying takes a single function that takes multiple arguments and turns it into a higher-order function with single arguments.\nLet\u0026rsquo;s take a look at the differences between the following functions:\nfrom operator import add add(2, 3) # two arguments def make_adder(n): return lambda x: n + x make_adder(2)(3) # higher order function with one argument in each Above, make_adder is an example of currying add(2, 3).\nA way to curry a function with any two arguments can be done like this:\ndef curryer(f): def g(x): def h(y): return f(x, y) return h return g What this does allows only a single argument to be passed into the function each time (similarly to make_adder), but because of the rules of name lookup in Python, the variables x, y, and f can still be accessible from the innermost function. You can try inputting it into PyTutor, but for this one, it\u0026rsquo;s a good exercise to try and draw it yourself before checking the answers.\n"},{"id":18,"href":"/docs/week-7/content/objects/","title":"Objects","section":"Week 7","content":"Objects\r#\r\rObject Oriented Programming (OOP)\r#\r\rOOP is a method for organizing programs. It includes\n Data Abstraction Bundling together related programs/information/behaviour  Each object can have its own local state (meaning its own variables), and also knows how to manage its own state.\nOOP is particularly useful when you have many similar things that can be further generalized to avoid repeating redundant code. For example, you could have an Animal object, with other sub-classes of the Animal (for example, Turtle, Cat, Bear, etc.) - this (inheritance) will be covered in the next page.\nTerminology\r#\r\r A class is a template for creating your own data type (for example, an Elephant class) An instance of a class is called an object (in this context, an instance would be one elephant in the Elephant class) Each object has its own variables called instance variables that describe its current state Each object can also have its own functions called methods Each class can have its own variables called class variables that contain information about the class itself  Example\r#\r\rLet\u0026rsquo;s make an Animal class.\nI want each of my animals to have instance variables for food and happiness as well as methods (equivalent to functions) to have animals play with each other.\nIn Python, whenever we want to create an instance of a class, we just assign a variable to a call to the class:\nThe example below won\u0026rsquo;t necessarily make sense for now, but I\u0026rsquo;ll break it down later into smaller parts that will each be explained.\nclass Animal: default_food = [] def __init__(self, name, energy = 100): self.name = name self.food = self.default_food[:] self.energy = energy self.times_fed = 0 def feed(self, food): self.food = self.food + [food] self.times_fed += 1 self.energy += 10 def play(self): if energy \u0026lt;= 20: return \u0026#34;Not Enough Energy\u0026#34; self.energy -= 20 self.is_happy = True # Creates new instance variable return f\u0026#34;{self.name}has {self.energy}energy.\u0026#34; my_cat = Animal(\u0026#34;Sochi\u0026#34;) my_cat.feed(\u0026#34;Tuna\u0026#34;) Object Construction\r#\r\rIn this case, Animal(\u0026lt;args\u0026gt;) is called the constructor.\nWhen our constructor (my_cat = Animal(\u0026quot;Sochi\u0026quot;)) is called, it does the following:\n Create a new instance of the Animal class Call the __init__ method of the class with the new instance as the first argument (passed in as self), along with any additional arguments in the call expression.  In this case, the new instance becomes self, and afterwards, is assigned to my_cat. This will hopefully make more sense after you see the diagram a bit below. The Pythonic term for a variable wrapped in double underscores is called a dunder method.    Instance Variables\r#\r\rclass Animal: default_food = [] def __init__(self, name, energy = 100): self.name = name self.food = self.default_food[:] self.energy = energy self.times_fed = 0 Instance Variables are variables that each instance of an object (most likely) has, which describes the state of the object. These instance variables can be modified using each of the object\u0026rsquo;s methods. Additionally, new instance variables can be assigned outside the constructor.\nDot notation here (for example with self.name) allows you to access all attributes of an object (including both instance variables and instance methods). The left-hand side does not need to be self - it can be anything that evaluates to an object instance (more on this later).\nIn this case, self refers to the instance being passed in - not every animal is the same, so self shouldn\u0026rsquo;t refer to the same animal. This might be more clear with the next example.\nMutating Instance Variables\r#\r\rclass Animal: default_food = [] def __init__(self, name, energy = 100): self.name = name self.food = self.default_food[:] self.energy = energy self.times_fed = 0 my_cat = Animal(\u0026#34;Sochi\u0026#34;) First, let me draw a representation of the Animal class that we\u0026rsquo;re referring to in the code block above. This is not the official Python Tutor environment diagram for a representation of classes, but this notation is a very clear way to see the lookup order of certain variables.\nI haven\u0026rsquo;t put every single method in the class\r\rAfterwards, when we call my_cat = Animal(\u0026quot;Sochi\u0026quot;), we create a new instance of the class. I will denote a new instance with a circle rather than a rectangle, label the newly created instance with my_cat (the name of the variable assigned to it), then an arrow will be drawn to the class that this instance refers to. This will be even more important when we look at inheritance in objects.\nNow, we can see that our variable my_cat has instance variables name, food, energy, times_fed, which can be mutated by either mutating my_cat or using methods, which we will show later.\nYou might be wondering where self.food comes from. In this case, self.default_food[:] will look for default_food in its own instance, which it can\u0026rsquo;t find because nothing is defined, so it will then look at the \u0026lsquo;frame\u0026rsquo; above, or in this case, the class itself for default_food, which it does contain. As a result, that value is used for self.food. You can think of this as variable lookup with different frames.\nTo mutate our instance, we can use my_cat to do so.\nmy_cat.energy += 10 Running the following line of code will look for whatever my_cat is pointing to, which in this case, is the instance, then find energy and update that.\nThis is sort of like list mutation: you can access an element in the instance by using dot notation, then update it through assignment.\nMethod Invocation\r#\r\rCalling my_cat.feed(\u0026quot;Tuna\u0026quot;) will invoke the following function:\nclass Animal: def feed(self, food): self.food = self.food + [food] self.times_fed += 1 self.energy += 10 This does the same thing as calling Animal.feed(my_cat, \u0026quot;Tuna\u0026quot;) if you want to see where the self variable comes from\r\rIn this case, my_cat gets implicitly passed in as self, so the first argument in my_cat.feed(\u0026quot;Tuna\u0026quot;) (Tuna) will get passed in to feed as food.\nAs a result, we will update our instance variables following the instructions in the function, where self refers to the instance we made in the image above.\nNotice how we have only updated the instance variables but not the class variables related to the (located in the rectangle). The new methods in the Animal class were already defined before, I added them in the image above for clarity reasons - (it shows where the function comes from)\r\r"},{"id":19,"href":"/docs/week-8/content/recursive-data/","title":"Recursive Data","section":"Week 8","content":"Recursive Data\r#\r\rLinked Lists\r#\r\rPython lists are implemented in a way that makes inserting and deleting from the front of a list very inefficient. This is because Python implemented a list such that the first element of the list is always at the same memory location and elements in a list are located right next to each other, so when something is inserted to the start, everything gets pushed forward by one space in memory to make space for an element.\nIf you ever need to constantly add to the front of a list, a Python list may not be a good idea. That\u0026rsquo;s where a Linked List can come in handy.\nImagine building a list where each element can be anywhere in memory, and all that needs to happen is that one element knows where the next is:\nI drew each node (or element) in a different location on the page just to illustrate that these blocks could be anywhere on the page and do not need to be directly next to each other like in a list. Each instance/element/node of our linked list just needs a value inside it, and an arrow pointing to the next linked list object. If we think of it this way, we can construct our own Linked List class.\nclass Link: empty = () # How we will refer to an empty linked list def __init__(self, first, rest = empty): self.first = first self.rest = rest Using this class, we can then define our first linked list!\nmy_link = Link(1, Link(2), Link(3)) # Notice how similar it is to the tree data abstraction you used earlier In the example above, 1 is what gets stored in self.first, while Link(2, Link(3)) is what gets stored in self.rest, meaning that we are able to continue accessing our linked list.\nHowever, you can notice one thing straight away!\nLink Class\r#\r\rA fancier version of the linked list that CS61A uses is the following:\nclass Link: \u0026#34;\u0026#34;\u0026#34;A linked list.\u0026#34;\u0026#34;\u0026#34; empty = () def __init__(self, first, rest=empty): assert rest is Link.empty or isinstance(rest, Link) # makes sure that the rest is either a linked list or emtpy self.first = first self.rest = rest def __repr__(self): if self.rest: rest_repr = \u0026#39;, \u0026#39; + repr(self.rest) else: rest_repr = \u0026#39;\u0026#39; return \u0026#39;Link(\u0026#39; + repr(self.first) + rest_repr + \u0026#39;)\u0026#39; # Returns the link class def __str__(self): string = \u0026#39;\u0026lt;\u0026#39; while self.rest is not Link.empty: string += str(self.first) + \u0026#39; \u0026#39; # Recursion!!! self = self.rest return string + str(self.first) + \u0026#39;\u0026gt;\u0026#39; Tree Class\r#\r\r"}]